# 도메인 이벤트
- 도메인 이벤트는 도메인 모델을 완벽히 지원하며, 도메인에서 일어난 어떤 사건을 나타낸다
- 도메인 로직에서 발생한 어떤 사건을 이벤트로 만들어 리스너에게 발행하고, 리스너가 알아서 처리하게끔 한다면 기존에 그렇게 하지 않음으로써 존재했던 복잡한 로직을 많이 제거할 수 있다
  - 시스템간 글로벌 XA 도 제거할 수 있다
- 도메인 전문가들의 말을 통해 도메인 이벤트를 포착할 수 있다
  - ~ 할 때, 그런 일이 일어나면, ~하면 저에게 알려주세요 등
- 이벤트가 로컬 시스템이든, 외부 시스템이든 관심이 있는 대상으로 전달됐을 땐 보통 결과적 일관성을 위해 사용된다
- 애그리게잇이 이벤트를 생성하는 것이 아닌, 클라이언트가 이벤트를 직접 생성하는 상황도 있다
  - 일반적인 케이스는 아니다
  - 취소를 취소한다 와 같이.. 도메인 로직은 아니지만 클라이언트가 직접 이벤트를 발생시키고 싶을 경우가 있다
  - 이런 상황에선 이벤트가 애그리게잇으로 설계될 수 있다

## 이벤트의 모델링
- 이벤트를 모델링할 땐 해당 이벤트가 속한 바운디드 컨텍스트의 유비쿼터스 언어에 따라 이벤트와 그 속성을 명명해야 한다
  - 이름은 보통 실행된 커맨드로부터 파생된다
  - BacklogItem#commitTo -> BacklogItemCommitted
- 이벤트는 과거에 일어난 일이므로, 이벤트의 이름은 일어난 사실을 반영해야 한다
- 이벤트에 필요한 속성
  - 언제 일어났는지 나타내는 타임스탬프가 필요하다
    ```java
    interface DomainEvent {
      public Instant occuredOn();
    }

    class BacklokItemComitted implements DomainEvent {
      private Instant occuredOn;
      // ...
    }
    ```
  - 이후는 팀과 함꼐 더 필요한 다른 속성이 무엇인지 결정하면 된다
  - 보통은 발생한 애그리게잇 인스턴스의 식별자를 포함하거나, 관련된 애그리게잇 인스턴스를 포함한다
    ```java
    class BacklokItemComitted implements DomainEvent {
      private Instant occuredOn;
      private BacklogItemId backlogItemId;
      private SprintId sprintId;
      private TenantId tenantId;
    }
    ```
- 이벤트는 보통 속성을 운반하려는 목적을 가지고 있으므로, 대부분의 이벤트는 전체 상태 초기화 메서드와 속성 읽기 접근자를 포함한다
- 이벤트 원인 이외의 상태까지 나타내길 원한다면, 속성을 더 추가하거나 오퍼레이션을 추가할 수 있다
  - 오퍼레이션으로 추가 상태를 나타내고자 할 경우, 값 객체처럼 오퍼레이션의 행동이 객체의 불변성을 유지시켜야 한다

### 식별자
- 이벤트를 서로 구분해야 할 때가 있지만, 기본적으로 그런 상황은 굉장히 드물다
- 그럼에도 불구하고 이벤트를 비교해야 한다면, 이벤트가 애그리게잇으로 설계됐다면?
- 기본적으로는 이벤트를 유발시키는데 관여한 애그리게잇 식별자와 발생한 타임스탬프를 통해 충분히 구분해낼 수 있다
  - 이벤트가 애그리게잇으로 모델링 된 상황이나, 이벤트의 속성만으로 이벤트를 구분할 수 없을 떄엔 식별자를 할당할 수 있다
- 이벤트가 외부로 전달될 경우, 원격 구독자로 하여금 중복 메시지 수신을 막는 로직이 필요하게 되고, 이 때 식별자가 필요하게 된다
  - 일부 메시징 인프라는 헤더에 식별자를 넣어서 모델이 이를 생성할 필요가 없도록 해준다
- equals, hashCode 구현 여부
  - 이벤트가 외부로 전달될 경우 보통 JSON 이나 XML 로 전달되고, 받는 쪽에서 원래 타입으로 재구성되지 않으므로이 부분은 따로 구현 할 필요없다
  - 반면 내부에서 전달되 원본 타입으로 재구성될 수 있다면, 이 부분을 구현해줘야 한다

## 도메인 모델에서 이벤트를 발행하기
- 도메인 모델이 어떤 종류의 메시징 인프라로 노출되지 않도록 해야한다
- 내부에서만 이벤트를 사용할 경우 경량 옵저버를 만드는 방법이 구현하기 가장 간단하다
  - 외부로 이벤트를 발행해야 할 경우 polling 이나 메시징 미들웨어를 쓰는 방법이 있다
- 도메인 로직내에서 발행자(DomainEventPublisher)가 이벤트를 직접 발행하며, 발행자는 어떠한 도메인 로직도 가지고 있지 않는다
- 이벤트 발행을 blocking 으로 처리할 경우 구독자가 다시 자신을 구독하지 않도록 별도의 처리가 필요하다
  ```java
  public <T> void subscribe(DomainEventSubscriber<T> subscriber) {
    if(isPublishing()) {
      return;
    }
    // ...
  }
  ```
- 스레드 풀을 사용할 경우 구독자 리스트가 공유될 수 있으므로 매번 초기화 해주어야 한다
- 구독자는 보통 애플리케이션 서비스에서 등록하며, 도메인 서비스에서 등록하기도 한다
- 이벤트의 발행에 앞서 구독이 이뤄진다
- 구독자가 또 다른 애그리게잇 인스턴스를 가져와서 변경을 유발하는 행동을 해선 안된다
  - 단일 트랜잭션당 단일 애그리게잇 인스턴스만 수정해야 하는 원칙을 침해한다
  - 같은 트랜잭션이 아닌 비동기적 수단을 통해 일관성을 강제해야한다

## 바운디드 컨텍스트간 일관성
- 바운디드 컨텍스트 사이에서 이벤트 전달을 위해 사용하는 모든 메시징 메커니즘을 사용하기 위해선, 결과적 일관성을 달성하려는 의지가 필요하다

### 메시징 인프라와의 일관성
- 도메인 모델이 사용하는 영속성 저장소와 메시징 인프라의 영속성 저장소는 항상 일관성을 보장해야한다
- 모델 변경의 저장이 이벤트 전달을 보장하고, 이벤트의 전달이 모델 변경의 저장을 보장해야 한다
  - 이 중 하나라도 같지 않다면, 상호의존적 모델이 정확하기 않은 상태에 빠지고 만다
- 이를 달성하기 위한 방법에는 아래의 방법들이 있다
  1. 도메인 모델과 메시징 인프라가 같은 영속성 저장소를 공유한다
    - 같은 트랜잭션에 있다는 의미이다
    - 메시징 시스템의 저장공간이 반드시 모델과 같은 데이터베이스에 위치해야 한다는 단점이 있다
  2. 도메인 모델의 영속성 저장소와 메시징 인프라의 영속성 저장소가 글로벌 XA 트랜잭션하에 제어된다
    - 글로벌 트랜잭션을 위한 특별한 지원이 필요하다
    - 글로벌 트랜잭션은 고비용이고 성능이 나쁜 경향이 있다
  3. 도메인 모델과 메시징 인프라가 같은 영속성 저장소를 공유하지만, 바운디드 컨텍스트가 이를 소유하고 제어한다
    - 1번과 비슷하다
    - 이벤트 저장소
    - 저장된 데이터를 메시징 인프라가 읽어서 전달한다(?)

### 자치 서비스
- 도메인 이벤트를 사용하면 어떤 수의 시스템이든 자치 서비스로 설계할 수 있다
  - 다른 서비스와 의존이 없는 시스템?(RPC 등을 통해)
- 서로 묶이는 RPC는 여러가지 문제를 유발한다
- 이 대신 비동기적 메시징을 사용해 시스템 사이에 높은 수준의 독립성을 달성할 수 있다

### 지연 시간
- 메시징 인프라를 사용해 일관성을 달성할 경우 **지연 시간** 이 문제를 유발할 수 있다
- 두 바운디드 컨텍스트 간에 일관성을 달성하기 위해 어느정도의 시간으 허용할지 신중하게 결정해야한다
  - 거의 실시간으로 이뤄줘야 하는 경우도 있고, 하루가 넘는 기간이 가능한 경우도 있다
- 실시간보다 결과적 일관성이 비즈니스 맥락에서 더 잘맞을지도 모른다
  - 각 단계로 넘어가는데 어쩌피 특정 시간 이상이 걸리는 경우가 있다
- 최대 허용 시간을 잘 이해해야 하며, 이를 만족시키면서도 더 잘 수행되도록 아키텍쳐 품질을 높여야한다

이벤트는 절대 유실되어서도 안되고, 중복되어서도 안되어야 하므로, 이를 수행할 수 있게 아케텍팅을 명확하게 해야한다  
이벤트 소싱을 쓰면 애그리게잇과 이벤트를 따로 저장하지 않고 이벤트 저장만 하고 끝이므로, 위에서 언급한 문제들이 발생하지 않는다?  

글로벌 트랜잭션을 사용하는 것 자체가 구현이 어렵고 부하가 너무 크다  
그러므로 이벤트를 사용하자  
트랜잭션을 다 열어놓고 모든 트랜잭션이 커밋되면 전체 커밋하고..  

멱등성을 보장하려고 할 때, state 가 여러개로 이어지는 애그리게잇의 경우 상태가 진행될 수록 이벤트 payload 가 너무 커지는 경향이 있다  

https://axoniq.io/  

업스트림, 다운스트림?  
worker? 그냥 어플리케이션?  
비동기식 커맨드 보다는 과거형태의 이벤트를 만드는게 어떨까?  