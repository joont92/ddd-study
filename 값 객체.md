# 값 객체
- 값 객체는 DDD의 필수 요소다
- 가능한 위치에선 엔티티 대신 값 객체를 사용해 모델링하도록 노력해야한다
  - 값 객체는 생성, 테스트, 사용, 최적화, 유지관리 등이 더 쉽다

# 값 객체의 특징

## 측정, 수량화, 설명
- 값 객체는 도메인 내에 있는 개념이 아니다
- 도메인 내에 있는 어떤 대상을 측정하고, 수량화하고, 설명하는 개념이다

## 불변성
- 객체가 인스턴스화 된 후 부터는 어떤 메서드도 값 객체의 상태 변경을 초래할 수 없다
  - **생성자를 제외한 어떤 메서드도 세터를 호출하지 못하도록 구현해야 한다**
- 생성자에선 해당 인스턴스 상태의 기반이 될 값을 매개변수로 받는다
- 엔티티 참조를 갖는 값 객체가 있을수도 있는데, 값 객체를 통해 엔티티의 속성을 변경하게 되면 결국 불변성을 위반하게 되므로 좋지 않은 디자인이다
  - 값 객체에서 엔티티의 값이 필요하다면 엔티티 대신 엔티티 내부의 속성을 전달하는 식으로 사용하는 것이 좋다

## 개념적 전체
- 값 객체는 하나 이상의 속성을 가질 수 있으며, 각 속성은 서로 연관돼 있다
- 특성이 모여 전체를 나타낸다
  - 모든 특성이 있어야만 완벽히 의도에 맞는 측정이나 설명이 만들어진다
  - 특성을 개별적으로 사용한다면 응집력 있는 의미를 제공하지 못한다
  - Grouping 과는 다르다
- 예시
  ```java
  class MonetaryValue implements Serializable {
    private BigDecimal amount;
    private String currency;

    public MonetaryValue(BigDecimal amount, String currency) {
      this.amount = amount;
      this.currency = currency;
    }
  }
  ```
  - `금액` 이라는 개념을 사용하기 위해선 amount 와 currency 가 같이 사용되어야 한다
- 관련 로직을 해당 값 객체로 중앙 집중화 할 수 있다
  ```java
  class ThingName implements Serializable {
    private name;
    
    public ThingName(String name) {
      this.name = name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();
    }
  }
  ```
- 값 객체 내의 전체 값 생성은 한번의 생성자 호출로만 수행되어야 한다
  - 초기값을 세팅하고, 이후 setter 등을 통해 값을 채워나가선 안된다
- 이 객체를 참조하고 있는 대상에게 이 객체는 하나의 속성이다
  ```java
  class ThingOfWorth {
    private ThingName name;
    private MonetaryValue worth;
  }
  ```

## 대체성
- 상태를 변경할 필요가 생겼다면, 새로운 값 인스턴스를 생성해 현재 값을 완전히 대체해야 한다
  ```java
  FullName name = new FullName("Vaughn", "Vernon");
  // ...
  name = new FullName("Vaughn", "L", "Vernon");
  ```
- primitive 타입의 값 교체와 동일한 방식이다
- `참조`라는 특성에서 올 수 있는 사이드이펙트를 최소화한다

## 값 등가성
- 값 객체 인스턴스간 타입과 특성이 모두 같다면, 해당 인스턴스들을 등가로 간주한다
- equals, hashCode 예제
  ```java
  @Override
  public boolean equals(Object obj) {
    if(obj == null || getClass() != obj.getClass()) {
      return false;
    }

    FullName target = (FullName) obj;
    return this.getFirstName().equlas(target.getFirstName()) 
            && this.getLastName().equals(target.getLastName());
  }

  @Override
  public int hashCode() {
    return Objects.hash(getFirstName(), getLastName());
  }
  ```
  - 자가 캡슐화를 사용해 이미 값에 대한 null 검증을 끝냈으므로, 등가비교에는 null 비교가 필요없다
- 애그리게잇에 사용되는 고유 식별자의 경우(e.g. MemberId) 대체성 특징이 필요하진 않지만, 그렇다고 값 객체로 사용할 수 없는것은 아니다

## 부작용이 없는 행동
- 특정 오퍼레이션을 수행할 때 어떠한 수정도 발생하지 않는다면, 해당 오퍼레이션은 부작용이 없다고 말한다
- 값 객체의 메서드는 부작용이 없는 메서드여야 한다
  - 불변성을 침해하지 않기 위해서이다
  - 함수형 프로그래밍 언어는 이런 특징을 강화하였다(불변성 값 객체만을 받아들이기 등)
- 예제
  ```java
  public FullName withMiddleInitial() {
    // validation
    return new Fullname(
      this.getFirstName(),
      middle.substring(0, 1).toUpperCase(),
      this.getLastName()
    );
  }
  ```
- 위에서도 언급했지만 매개변수로 전달한 인스턴스의 값이 변경되는 것도 부작용이다
  - 값 객체에 엔티티를 전달하지 말고 내부 속성 일부만을 전달하도록 변경하는 것이 좋다
- primitive 타입의 경우 이런 함수를 할당할 수 없다(우리 도메인에 맞는)
- 정말 특별히 처리할 부분이 없는 단순한 특성이라면, primitive 타입을 사용해도 괜찮다

# 표준 타입
- 시스템과 어플리케이션은 표준 타입이 필요하다
  - enum 같은 것을 말함
  - 장점은 생략
- 엔티티로 볼 수도 있지만, 가능하면 값으로 바라보는 것이 좋다
- 표준타입은 identity, name, description 같은 특성들을 가진다
- 자바 열거형(enum)을 사용하면 아주 간단히 이를 표현할 수 있다
- 표준 타입이 텍스트 설명을 가지는건 때때로 부적합하다
  - 뷰에 따라 달라질 수 있으므로(지역화 등)

# 값 객체 테스트
- Test First Style
  - 모델이 모든 측면에서 완벽하다고 증명하려는 목적이 아님
  - 클라이언트가 도메인 모델의 다양한 객체를 사용하는 방법과 해당 클라이언트가 이를 사용할 때 기대하는 결과가 무엇인지에 더 관심이 많음
- 모델을 설계하며 필수적인 개념을 포착하기 위해선 클라이언트의 관점을 가정해보는 과정이 필수적이다
- 팀의 표준을 다루는 모든 추가적인 테스트는 반드시 작성해야 한다
- 테스트는 반드시 도메인 전문가의 입장에서 의미가 있어야 한다
  - 비기술적인 도메인 전문가는 이 테스트를 읽고 이해할 수 있어야 한다
- 테스트를 위해 테스트 클래스 내 헬퍼 메서드를 만들 수 있다
- 값 객체의 메서드를 수행 후 등가비교를 수행함으로써 부작용이 발생하지 않았는지 체크한다
  ```java
  SomeValue someValue = new SomeValue(/* */);
  SomeValue someValueCopy = new SomeValue(someValue);
  
  someValue.doSomething();
  
  assertThat(someValue).isEqualTo(someValueCopy);
  ```
  - 값 객체를 사용할 경우 모든 경우에서 불변성이 보장된다

# 구현
- 값 인스턴스는 직렬화가 필요한 경우가 있어서 Serializable 로 선언하는게 좋다(?)
- 값 객체의 경우 생성자를 최소 2개 작성해주는 것이 좋다(필자의 의견)
  - 값 객체를 생성하는데 필요한 매개변수들이 있는 생성자
  - 기존의 값을 복사해 새로운 값을 생성하는 복사 생성자
    - 기본적으로 swallow copy 를 사용함
    - deep copy 를 지원할수도 있지만 대개 불필요하다
      - 불변 값을 다루기 때문에 인스턴스 사이에 객체가 공유되어도 문제가 되지 않기 떄문이다
    - 이 생성자는 불변성 검증 단위 테스트에서 주로 활용된다
- 함수의 메서드 이름 또한 중요하다
  - 자바빈 명세인 getXXX 보단 명시적인 이름을 사용하자(e.g. getValuePercentage() -> valuePercentage())

> 자바빈 명세는 객체 설계에 부정적인 영향을 미쳤다  
> 자바빈 명세를 지킬경우 객체는 불변성을 위반하므로, 이 형태로 객체를 작성해서는 안된다  
> 만약 특정 라이브러리나 프레임워크에서 자바빈 명세를 필요로 한다면, DTO 를 사용해 이를 해결해보는 것이 좋다  

- 등가 조건을 위해서 equals(), hashCode() 를 구현해야 한다
- 자가 캡슐화를 하고, 여기서 assertion 을 수행해주는 것이 좋다
  - 잘못된 데이터를 받지 않을 수 있도록 막아주기 때문이다
  - 만약 데이터가 잘못되었다면 IllegalArgumentException 을 발생시킨다