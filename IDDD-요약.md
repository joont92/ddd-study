### DDD 란?
- 비즈니스 도메인을 소프트웨어에 최대한 녹여가며 개발하는 방법
  - `은행이 이자를 계산한다` 같은 도메인 지식이 코드에 그대로 들어가게 됨
- **OOP 를 도메인 전문가와 같이 하라**
- 개발자와 비즈니스 전문가간에 용어 통일(유비쿼터스 언어)
- 개발자의 사고방식부터 바껴야 한다(우리가 더 비즈니스에 집중해야 한다)
- 비즈니스 파급력이 가장 큰 도메인부터 적용해야 한다
  - 우리 MSA 서비스를 만들떄는 이 부분을 생각하지 못하고 디펜던시부터 생각했었다
  - 결국 디펜던시가 항상 가장 작은 프로젝트부터 시도하려고 했었다

### 바운디드 컨텍스트
- **도메인은 코드로 표현되는 어떤 경계가 아니라 단순한 논리적 개념일 뿐이다**
  - `도메인 모델`이 실제 코드로 표현되는 부분이다
- 바운디드 컨텍스트는 도메인 모델의 존재를 담고 있는 명시적 경계이다
  - 바운디드 컨텍스트는 대체적으로 하나의 물리적 시스템이다
- 하나의 바운디드 컨텍스트에 여러 도메인이 있을 경우(일반적인 레거시), 여러 도메인을 합쳐 하나의 도메인을 만들려고 하지 말아야 한다
  - 사실상 불가능하다(용어의 충돌이 매우 많이 일어나게 됨)
  - 하나의 바운디드 컨텍스트 내 여러 도메인이 있다면 패키지로라도 구분해주는 것이 좋다
  - 여러 서브 도메인을 포함한 바운디드 컨텍스트는 성장의 속도가 느리다(확장할 때 마다 다른 도메인이 발목을 잡음)
- 도메인 모델내에 존재하는 개념은 해당 도메인 모델을 둘러싼 바운디드 컨텍스트와 언어적 연관성이 있어야 한다
  - 협업 바운디드 컨텍스트와 `사용자` 라는 모델은 연관성이 별로 없다
- 마이크로서비스는 바운디드 컨텍스트를 각각 프로세스로 분리하여 모델이 자연스럽게 컨텍스트별로 분리되게 하며, 라이프사이클도 각자 가져가게 한다

### 아키텍처
- 실재하는 진실된 품질 요구사항이 아키텍처를 결정하도록 해야한다
  - 정당화할 수 없는 아키텍처는 시스템에서 제거해야 한다
- 계층형 아키텍처
  - 계층 종류
    - 사용자 인터페이스
      - 뷰 요구사항만 처리
      - 값이 제대로 들어왔는지 정도만 유효성 검사
      - 도메인 지식이 포함된 유효성 검사는 여기서 수행하지 않음
    - 애플리케이션
      - 도메인 로직이 전혀 없음
      - 매우 경량으로 유지됨
      - 트랜잭션, 보안을 제어함
      - 애플리케이션 서비스가 복잡하다면 도메인 로직이 애플리케이션 서비스로 새어나가고 있음을 나타내는 신호일 수 있다
    - 도메인
      - 실제 도메인 객체들
      - 도메인 로직은 모두 여기서 수행해야 한다
    - 인프라스트럭쳐
      - DB, Message Queue, Email 등
      - 이 계층은 DIP 를 사용해서 접근해야 한다
        - 실제 구현체에 접근하지 않고 추상화된 계층을 통해 접근한다
        - 인프라스트럭쳐는 이 추상화된 계층을 상속하며 의존한다
        - 추상화된 계층은 도메인 계층과 레벨이 같다
        - 어플리케이션 계층에서 이 추상화 계층을 사용하게 되면 어플리케이션 -> 도메인 -> 인프라스트럭쳐의 순서를 달성할 수 있게 된다
  - 상위 수준은 하위 수준의 모델에만 의존해야 한다
    - 어플리케이션 계층에서 인터페이스 계층의 모델을 사용해선 안된다
    - 보통 서비스 계층이 따로 모델을 가지는 경우는 별로 없으므로, 도메인 모델을 직접적으로 사용해도(파라미터, 반환) 괜찮을 것 같다
- 헥사고날
  - 애플리케이션 + 도메인 계층을 하나의 계층으로 두고, 여기에 여러 클라이언트(포트)들이 핸들러(어댑터)를 통해 연결되어 있는 형태이다
  - 관점의 차이인 것 같다
    - 어플리케이션 + 도메인을 크게 하나로 보고, 다른 것들은 나머지로 분류한다
- 아키텍처 스타일 : 해당 아키텍처를 사용할 때의 베스트 프랙티스
  - RDB를 사용하면서 테이블 하나에 직렬화된 객체를 그대로 저장하고 있다거나, REST 를 사용하면서 HTTP의 이득을 하나도 얻고 있지 못하다면, 해당 시스템에는 다른 아키텍처가 더 맞다고 볼 수 있다
- CQRS
  - CUD 와 R 이 같은 도메인 내에 존재하다보면 도메인 모델의 복잡도가 증가하고, 기존에 설계했던 도메인 모델의 모습에서 점점 멀어지는 형태가 나타난다
  - 이를 해결하기 위해 명령(CUD) 부분과 조회(R) 부분을 분리하여 개발하면 된다는 결론이 나왔는데, 이게 CQRS 이다
  - 커멘드와 쿼리를 같은 저장소 내에서 분리할 수도 있고, 아예 다른 저장소를 사용할 수도 있다
    - 다른 저장소일 경우 이벤트를 이용해 동기화를 처리한다

### 엔티티
- 긴 시간에 걸쳐 계속 변화할 수 있는 고유한 대상(고유 식별자를 가짐)
- **라이프사이클에서 필수적인 행동들을 위주로 작성하고, 그 행동에서 필요로 하는 특성만을 추가해야 한다**
- 식별자 생성 전략
  - 애플리케이션이 직접 식별자 생성
    - UUID 또는 자체 포멧
    - String 보다는 VO 로 만들어주는 것이 좋음
  - 영속성 메커니즘이 식별자 생성
    - 데이터베이스까지 가야한다는 단점이 있다
  - 또 하나의 바운디드 컨텍스트가 식별자를 할당한다
    - 통합 유저 시스템(UAA)
- 하이버네이트 같이 대리 식별자를 선호하는 기술에서는, 대리 식별자와 도메인 식별자를 만들고 대리 식별자를 외부에 감추는 것이 좋다
  ```java
  public abstract class IdentifiedDomainObject {
    private Long id = -1;

    public IdentifiedDomainObject() {
      super();
    }

    protected setId(Long id) {
      this.id = id;
    }

    protected Long id() {
      return this.id;
    }
  }

  public abstract class IdentifiedValueObject {
    public IdentifiedValueObject() {
      super();
    }
  }

  /*
  value object extends IdentifiedValueObject
  entity extends IdentifiedDomainObject
  */
  ```
- 생성자는 필수로 들어가야 할 속성들을 꼭 포함해야 하며, 전달되는 값이 절대 null 이 되어서는 안된다
- 단순 null 체크 외 유효성 검사 로직을 넣어서 도메인 로직이 꺠지지 않게끔 유지해줘야 한다
- self setter 를 사용한 유효성 검사
  ```java
  class EmailAddress {
    public EmailAddress(String address) {
      this.setAddress(address);
    }

    private void setAddress(String address) {
      if(address == null) {
        throw new IllegalArgumentException("address may not be set to null");
      }
      if(address.length() == 0) {
        // ...
      }
      // ...
      this.address = address;
    }
  }
  ```
- 전체 엔티티 유효성 검사
  - 필드 여러개를 합친 유효성 검사를 해야 하는 경우가 있을 수 있다 
    - e.g. 주문 상태는 완료인데 주문 완료시각이 null 이 될 수 없어야 함
  - 이 부분도 엔티티에 넣을 수 있는데, 그러기엔 엔티티의 책임이 너무 많아지니 따로 Validator 클래스로 빼는게 나을수도 있다
  - 그리고 어플리케이션 계층에서 이 Validator 객체를 호출한 뒤 로직을 수행하도록 할 수 있다(직접 가져와서 validate 검사해서는 안됨)
- 엔티티 변화 추적
  - 종종 엔티티에서 일어나는 중요 사건들을 추적해야 할 떄가 있는데, 이때 도메인 이벤트를 활용하는 것은 좋은 방법이다

### 값
- 라이프사이클, 히스토리를 관리할 모델만 엔티티로 만들고 나머지는 전부 값 객체로 만드는 것이 좋다
- 생성, 테스트, 사용, 최적화, 관리 등이 훨씬 간편하다
- 고유 식별자가 없다
- 부작용이 없다
  - 불변성 : 객체가 인스턴스화 된 후 부터는 어떤 메서드도 값 객체의 상태를 변경할 수 없다
  - 상태를 변경할 필요가 생겼다면, 새로운 값 인스턴스를 생성해 현재 값을 완전히 대체해야 한다
  - `참조`로 인해 발생하는 사이드이펙트를 없앤다
- 값 객체가 엔티티의 참조를 가지는 것은 좋지 않은 디자인이다
  - 엔티티의 속성을 전달하도록 하는 것이 좋다
- 여러 특성들을 응집하여 하나의 값 객체가 된다
  - grouping 과는 다르다
  ```java
  @Value
  class Money {
    private BigDecimal amount;
    private String currency;
  }
  ```
- 이 객체를 참조하고 있는 대상에게 이 객체는 하나의 속성이다

- 값 객체 인스턴스간 타입과 속성 모두 같다면, 두 인스턴스가 동일하다고 간주한다
- 값 객체의 경우 생성자를 최소 2개 작성해주는 것이 좋다
  - 값 객체를 생성하는데 필요한 매개변수들이 있는 생성자
  - 기존의 값을 복사해 새로운 값을 생성하는 복사 생성자
    - swallow copy
    - deep copy 는 대게 불필요함(불변값을 다루기 때문에 인스턴스 사이에 객체가 공유되어도 문제되지 않음)
- 설계시 데이터 모델부터 거꾸로 올라오지 말고, 도메인 모델로부터 데이터 모델로 내려가야 한다
  - 데이터 모델은 도메인 모델을 영속화하는데 사용할 뿐이다
- 단일 값 객체 저장
  - 비정규화하여 같은 테이블에 저장한다
- 컬렉션 값 객체 저장
  - 객체를 JSON 으로 직렬화하여 저장한다
    - 검색이 불가능해짐
  - 식별자를 감추고 1:N 로 연결한다
  - elementCollection 을 사용한다(따로 식별자를 가지지 않음)

### 도메인 서비스
- 한 애그리게잇으로는 구현할 수 없는 도메인 로직이 있을때가 종종 있다
  - 대표적 예가 결제 금액 계산 로직이다(상품, 주문, 할인, 회원 애그리게잇 등이 필요함)
- 해결법으로는 애그리게잇이 다른 애그리게잇을 필드로 가지는 방법인데, 이는 좋은 방식이 아니다
  - 애그리게잇이 자신의 책임 범위를 넘어서는 기능을 구현하게 되기 때문이다
- 애플리케이션 계층에서 애그리게잇들을 가져와 로직을 수행하는 방법도 있는데, 이 또한 좋은 방식이 아니다
  - 애플리케이션 서비스가 도메인 로직을 너무 많이 알게되는 단점이 생긴다
- 이를 위해 애그리게잇들을 모아서 도메인 로직을 수행하는 객체가 생기게 되었고, 이를 도메인 서비스라고 부른다
- 애플리케이션 서비스와는 다르다
  - 트랜잭션을 다루지 않음
  - 도메인 로직이 올 수 있음
- 어플리케이션 서비스에서 사용할 수 있고, 애그리게잇의 파라미터로 전달할 수 있다
  ```java
  // 직접 사용
  authenticationService.authenticate(/* ... */);

  // 파라미터로 전달
  public class Order {
    public Money calculate(DiscountCalculationService discountCalculationSvc, /* ... */) {
      // ...
    }
  }
  ```
  - 파라미터는 괜찮으나 애그리게잇의 필드로 도메인 서비스를 가지는 것은 좋지 않다
  - 해당 애그리게잇이 이 도메인 서비스의 로직과 직접적으로 관련이 없기 때문이다
- 도메인 서비스는 무상태로 구현해야 한다
- 도메인 서비스에 애그리게잇을 파라미터로 전달해도 되고, 도메인 서비스 내에서 repository 로 조회해도 된다
- 도메인 서비스에 너무 의존해서는 안된다
  - 신중하게 사용하지 않으면 도메인 서비스에 너무 많은 로직이 몰릴 가능성이 있다
- 도메인 서비스는 singleton 객체로 등록해놓고 사용한다
- 도메인 서비스를 파라미터로 넘기는 상황들을 감안해보면, 애그리게잇을 파라미터로 받기보다는 애그리게잇 id 를 파라미터로 넘기거나 도메인 서비스내에서 애그리게잇을 직접 조회하는 것이 좋을 것 같다
  - 애그리게잇 자체를 파라미터로 넘기는 형태라면, 애그리게잇에 도메인 서비스를 직접 넘길경우 애그리게잇에서 다른 애그리게잇을 조회할 방법이 없어지기 때문이다

### 도메인 이벤트
- 도메인에서 발생한 어떤 사건을 이벤트로 만들어 발행한다
- 이 패턴을 사용하면 기존에 이렇게 하지 않음으로써 존재했던 복잡한 로직을 많이 제거할 수 있다
- 이벤트의 이름은 보통 실행된 커맨드로부터 파생된다
  - BacklogItem#commit -> BacklogItemCommited
- 이벤트가 언제 일어났는지 나타내는 타임스탬프 핖드가 필요하다
- 이벤트에 오퍼레이션을 추가했다면, 오퍼레이션의 행동이 객체의 불변성을 유지시켜야 한다
- 이벤트는 기본적으로 식별자가 딱히 필요없다
  - 이벤트가 발생한 애그리게잇의 식별자와 타임스탬프로 충분히 구분해낼 수 있기 때문이다
- 이벤트가 외부로 나간다면 중복처리 방지 등을 위해 식별자가 필요할수도 있다
- 이벤트가 외부로 나갈경우 equals 나 hashCode 를 구현할 필요 없다
  - 역직렬화하면 재생이 안되기 때문이다
- 모델이 변경되어서 저장되었다면 반드시 이벤트가 외부로 나가는 것을 보장해야 한다
- 이벤트는 절대 유실되거나 중복되지 않아야 하므로, 이를 수행할 수 있는 아키텍팅을 명확하게 해야한다
- 이벤트가 유실될 것을 염려하여 스냅샷 형태로 이벤트를 정의하는것은 좋은 방식이 아니다
  - 이벤트 유실 문제를 다른 방법으로 풀어내야 한다(e.g. PersistentEvent)
  - 매번 스냅샷을 보내는것은 페이로드가 너무 크고, 받는쪽에서도 이를 이용해 정합성을 맞추는 코드를 구현하기가 복잡하다
- 이벤트를 통해 일관성을 달성하는 경우 `지연 시간`이 어느정도까지 허용되는지 신중하게 결정해야 한다

### 모듈

### 애그리게잇
- 애그리게잇은 엔티티나 VO 같이 특정 엔티티를 얘기한다기보단, 엔티티 경계에 관한 특정 룰 이라고 볼 수 있을 것 같다
- 고정자 : 일관성을 트랜잭션 레벨로 유지해줘야 하는 속성들
- 이러한 고정자의 단위가 애그리게잇의 단위가 될 수 있다(?)
- 한 트랜잭션당 한 애그리게잇 인스턴스만을 수정해야한다
  - `왜 꼭 이래야만 할까?`
- 하나의 애그리게잇 인스턴스에서 커맨드를 수행할 때 다른 애그리게잇의 커맨드도 수행되어야 한다면, 이벤트를 사용한 결과적 일관성을 사용하는 것이 좋다
  - `이벤트를 사용하는것 까진 좋으나, 왜 꼭 결과적 일관성으로 가야하는걸까?(다른 서비스도 아닌데)`
  - `도메인 서비스를 파라미터로 던졌을때는 조회만 사용하는 것이 좋을까?`
- 작은 애그리게잇으로 설계하는 것이 좋다
  - 덩치가 크면 확장성이 떨어진다
  - Optimistic Locking 이 발생할 확률이 높아진다
  - 대체적으로 애그리게잇은 하나의 루트 엔티티와 여러(최소한의) 값 객체들로 이루어져 있다
- 애그리게잇 간에는 직접 참조 대신 ID 로 참조해야 한다
  - **애그리게잇간에 의존이 심해지는 상황을 방지하기 위한 장치이다**
  - 여러 애그리게잇이 로직을 수행해야 할때는 어플리케이션 레이어에서 하거나, 이벤트를 통해 수행해야 한다
  - 파라미터로도 전달하지 말아야한다(애그리게잇의 경계가 무너짐)
- 애그리게잇 내에서 리파지토리로 애그리게잇을 조회하게끔 하면 안된다
  - 이 또한 애그리게잇의 경계를 무너트리는 행위이다
- 애그리게잇의 상태 수정은 클라이언트가 수행하는것이 아닌, 애그리게잇만이 수행할 수 있다(tell, don't ask)

### 리파지토리

### 바운디드 컨텍스트간 통합
- XML, JSON 을 이용해 주고받는것이 좋음
- REST API, 메시징
- 도메인 이벤트 + 메시징 아키텍처 형태가 DDD 에 좋다
- 이벤트 발행자가 이벤트 수신자를 책임질 수 없다
  - 이벤트 발행까지만 하고, 나머지 책임은 수신자에게 맡기자
- SAGA 패턴?

### 애플리케이션

---

- 파라미터로 VO 는 괜찮고, 애그리게잇은 애그리게잇 id 를 넘기도록 한다
- 모든 전략적 기술들을 보면, 다 경계에 관한 전략들이다
  - 애그리게잇, 엔티티, VO 등 
  - 경계가 무너지는 순간 해당 객체를 다루기가 힘들어지고, 이는 유지보수와 개발의 어려움으로 이어진다
  - 객체지향은 결국 이를 편하게 하기 위해 나온 기술이 아니던가