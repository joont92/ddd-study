# 엔티티
- 긴 시간에 걸쳐 계속 변화할 수 있는 고유한 대상(고유 식별자를 가짐)
- 모델을 정의할 때 식별자와 그에 따른 수명주기에 집중하여야 한다
  - 엔티티의 특성이나 행동보단, 엔티티 객체를 식별하거나 매칭해서 찾을 떄 사용되는 엔티티 객체의 정의를 기본적인 특성까지 파고들어야 한다
  - **개념적으로 필수적인 행동과 그 행동에서 필요로 하는 특성만을 추가해야 한다**

# 엔티티 식별자 생성 전략

## 사용자가 식별자를 제공한다
- 양질의 식별자를 생성하는 일을 사용자에게 의지하는 것이 좋지 않은 접근이다
  - 고유하더라도 올바르지 않을 수 있기 때문이다
- 사람이 읽을 수 있는 식별자가 반드시 필요한 상황에선 어느정도 적합할 수 있다
  - 식별자의 품질을 확보하려고 노력해보는 것도 좋은 투자가 된다
- 수정가능한 사용자 입력값은 고유 식별자로 사용해선 안된다

## 애플리케이션이 식별자를 생성한다
- UUID
  - 하이픈 포함 36 바이트, 하이픈 제외 32 바이트
  - 영속성 메커니즘과 같은 외부 교류가 필요없고, 상대적으로 생성이 빠른 식별자이다
    - 1초 동안 특정 종류의 엔티티가 무수히 생성되더라도 속도를 유지할 수 있다
  - 읽기 힘들기 때문에 일반적으로 사용자로부터 감춰지고, 대신 사람이 읽을 수 있는 참조기법을 사용한다
    - \<a\> 태그로 UUID 를 감출 수 있다
- UUID 의 개별 세그먼트의 신뢰 정도에 따라 아래와 같은 형태로 re-format 할수도 있다
  ```
  reformatted id : APM-P-2012-08-14-F36AB21C

  APM 은 컨텍스트 이름,  
  P는 Product 라는 리소스 이름,  
  2012-08-14 는 년도-월-일,  
  마지막 8글자는 생성된 UUID 의 초기 4byte
  > TIMESTAMP 에서 마지막 32bit를 나타낸다(second, millisecond, nanosecond 포함?)
  
  위처럼 ID 를 재구성했을 경우 아래와 같은 이점들이 있다
  - 클라이언트가 원시 식별자 포멧을 이해할 필요가 없다(가독성이 올라감)
  - 식별자내에서 추가적인 정보 획득 가능(생성 날짜, 리소스명)
  ```
  - 이렇게 reformat 된 식별자는 String 보다는 VO 를 써서 유지해주는 것이 더 맞다(e.g. ProductId)
- 애플리케이션이 제공하는 식별자를 위해 필자는 리파지토리를 사용한다고 한다
  ```java
  public class JpaProductRepository implements ProductRepository {
    public ProductId nextIdentity() {
      UUID uuid = UUID.randomUUID();
      /*
      process uuid
      */
      return new ProductId(processedUUID);
    }
  }
  ```

## 영속성 메커니즘이 식별자를 생성한다
- 데이터베이스로 sequence나 incremented 값을 얻었을 경우 결과는 언제나 고유하다
- 필요한 범위에 따라 2byte, 4byte, 8byte 의 고유값을 생성할 수 있다
- 값을 얻기 위해 데이터베이스까지 가야한다는 점이 단점이다
  - 애플리케이션에서 생성할 때 보다 많은 시간을 소모한다
  - 애플리케이션 내부에 값을 캐싱하는 방법도 있지만, 딱히 실용적이지 않다
- 데이터베이스 종류에 따라 `빠른 식별자 생성`과 `늦은 식별자 생성` 2가지 방식이 있다
  - 빠른 식별자 생성은 엔티티 저장전에 식별자를 얻을 수 있는 방법을 말한다
    - e.g. Oracle
  - 늦은 식별자 생성은 생성자 할당이 엔티티가 저장될 때 일어난다
    - e.g. MySQL
    - MySQL의 LAST_INSERT_ID 를 사용해 Oracle Sequence와 비슷하게 사용할 수 있다(참고 : <https://bryan7.tistory.com/101>)

## 또 하나의 바운디드 컨텍스트가 식별자를 할당한다
- 다른 바운디드 컨텍스트에서 검색해서 식별자를 가져오므로, 바운디드 컨텍스트간 통합이 필요하다(식별자의 검색과 매칭과 할당을 위함)
- 검색을 위해 계좌번호, 사용자명, 이메일 등과 같은 속성을 하나 이상 제공해야 한다
  - 여러 검색 결과가 나오는 경우 사용자가 선택할 수 있는 UI 도 필요하다
- 외부 바운디드 컨텍스트의 변경이 로컬 바운디드 컨텍스트에 영향을 미친다
  - 이때는 도메인 이벤트를 사용한 동기화가 필요하다
  - 경우에 따라 로컬 바운디드 컨텍스트가 외부 바운디드 컨텍스트로 push 를 하기도 한다
- 이 방법은 식별자 생성 전략 중 가장 복잡한 방법이므로(외부에 의존적이므로), 최대한 보수적으로 사용해야 한다
- UAA 통합 사용자 같은것이다..

> - 어떤 식별자 할당 접근법을 사용했는지, 왜 사용했는지 적어보자
> - 빠른 식별자 생성으로 충분한지, 늦은 식별자 생성으로 충분한지 적고 이유를 적어보자

## 식별자
- 바운디드 컨텍스트간 이벤트를 주고받을 떄, repository 에 저장하기 전에 이벤트를 발생시킬 경우 항상 빠른 식별자 생성 전략을 써야한다
- 저장되지 않은 엔티티를 Set에 넣을 경우 식별자가 없으므로, 동등성 비교를 제대로 수행할 수 없게 된다
  - 식별자가 아닌 다른 속성과 비교하도록 구현해야 할수도 있다
  - 필자의 경우 이런 상황이 발생한다면 다른 속성 비교를 구현하기 보단 빠르게 가져와서 할당하는 방법을 선호한다고 한다
- 하이버네이트는 숫자 시퀀스와 같은 원시 타입(대리 식별자)을 식별자로 사용하는 편을 선호한다
  - 외부에는 이런 대리 속성을 감추는 편이 가장 바람직하다(도메인 모델의 일부가 아니기 때문)
  - 대리 식별자 외에 도메인 식별자를 추가로 만들어주는 것이 좋다
    - id : 대리 식별자, tanant_id + username : 도메인 식별자
- 식별자는 외부에서 수정되지 못하도록 해야한다
  - setter 를 숨긴다
  - setter가 이미 있다면 내부에 방어 코드를 작성한다(2번 이상 setting 될 경우 exception 등)
- 변경되는 값은 식별자로 사용할 수 없다
  - username 은 식별자가 될 수 있으나, password 의 경우 식별자가 될 수 없다

# 엔티티 만들기
- 아래는 책에 나온 사스오베이션 팀의 요구사항을 예시로 설명한다
- 요구사항 분석을 진행하면서 팀 내의 유비쿼터스 언어집을 만들고, 계속 다듬어가는 것이 좋다
  ```
  # 용어집 예제
  테넌트 : ~~~
  테넌트 활성화 : ~~~
  사용자 : ~~~
  암호화 서비스 : ~~~
  인증 서비스 : ~~~
  ```

## 속성 만들기
1. 불분명해 보이는 요구사항은 완전히 다시 정리해보는 것이 좋다
  - 분명한 부분들을 추출해낼 수 있다
  - 요구사항이 완성인지 미완성인지 체크할 수 있다
2. 요구사항을 읽고, 필요한 것이 엔티티인지 값 객체인지 판단한다
  - `변경된다` 라는 단어를 분석한다
    - 특정 값만 바꾸면 되는지, 값 전체가 변경되어야 하는지에 따라 엔티티냐 값 객체냐를 판단할 수 있다
    - 지금은 값 전체를 바꿀 필요없다
  - `인증` 이란 단어는 검색을 지원해야한다는 뜻이며, 이는 고유 식별자가 필요하다는 의미이다
    - 검색은 많은 대상 중 하나를 발견하기 위함이기 때문이다
  - 위와 같은 특징들로 봐서, 엔티티라고 확신할 수 있다
3. 엔티티인게 확정되었으므로, 식별자와 속성을 정의해야 한다
  - 엔티티가 사용되는 범위에 따라 식별자를 정의한다
    - 광범위하게 사용될 Tenant는 UUID를 식별자로, Tenant 내에서만 식별하면 되는 User는 username 을 식별자로 사용한다
  - 다른 엔티티에서도 사용될 광범위한 식별자라면, primitive 타입보단 특정 타입을 지정해주는게 더 좋다(e.g. TenentId)
  - 검색을 위한 필드도 추가 정의한다
4. 속성의 노출 범위를 지정한다
  - password 필드는 애그리게잇 범위를 넘어선 절대 드러나지 않고, AthenticationService 를 통해서만 접근할 수 있게 한다
  
## 행동 정의하기
1. 요구사항 내에서 엔티티의 행동을 찾는다
  - e.g. 테넌트 활성화, 사용자 초대 등
2. 한 엔티티에 너무 큰 책임이 부여될 경우, 별도의 엔티티로 분리할 수 있다
  - e.g. User 엔티티에서 개인적 데이터를 담는 부분을 Person 엔티티로 분리
3. 다른 애그리게잇과 동기화가 필요하다면 이벤트를 발생시킬 수 있게끔 한다

### 역할 인터페이스
- 경우에 따라 한 객체가 여러 역할을 모두 수행하게 만들수도 있는데, 이 경우 인터페이스로 구분해주는 것이 좋다
  ```java
  interface User { /* ... */ }
  interface Principal { /* ... */ }
  class UserPrincipal implements User, Principal {
    // ...
  }
  ```
- 위의 경우 역할 인터페이스의 범위가 큰데, 좀 더 작은 단위로 역할 인터페이스를 만드는게 좋을수도 있다
  ```java
  interface AddOrdersToCustomer { /* ... */ }
  class Customer implements AddOrdersToCustomer {
    // ...
  }

  ...

  AddordersToCustomer customer = customerRepository.get(id);
  customer.addOrder(order);
  ```
- 인터페이스를 통해 구현 클래스에서 필요한 부분만 노출시킬 수 있다
  - 도메인 모델 구현 클래스는 지저분할 수 밖에 없다
- 위임은 복잡하게 만들지 않으며 단순하게 해줄때만 좋은 설계다
  - 아래는 복잡한 위임의 예시이다
  ```java
  interface Principal{ /* ... */ }
  class PersonPrincipal implements Principal { /* ... */ }
  class SystemPrincipal implements Principal { /* ... */ }
  class UserPrincipal implements Principal {
    PersonPrincipal personPrincipal;
    SystemPrincipal systemPrincipal;

    @Override
    public Name principalName() {
      if(personPrincipal != null) {
        return personPrincipal.principalName();
      } else {
        return systemPrincipal.principalName();
      }
    }
  }
  ```
  - UserPrincipal 이 위임을 하면서 자신의 식별자를 유실시켰는데, 이를 객체 정신 분열증이라고 한다

## 생성
- 새로운 엔티티를 인스턴스화할 때, 이를 완전히 식별해 클라이언트가 찾을 수 있도록 충분한 상태 정보를 가질 수 있게하는 생성자를 사용해야 한다
- 올바른 생성자는 최소 고유식별자를 매개변수로 가지고, 엔티티가 이름 등으로 쿼리된다면 그 모든 사항도 매개변수로 포함시킨다
- 생성자에 나열한 필수 속성들은 이후에 절대 null 이 되어선 안된다
  - 필수속성들이 꼭 고정자일 필요는 없지않는가?
  - setter 에 방어코드를 넣어서 이를 보장해야 한다
- 복잡한 엔티티 인스턴스화를 위해선 팩토리를 사용하는 것이 좋다
  ```java
  class Tenant {
    public User registerUser(String userName, String password) { // 팩토리
      return new User(
        this.tenantId(),
        userName,
        password
      );
    }
  }
  ```
  - User 생성자는 protected 접근제어자를 사용하므로, 같은 애그리거트인 Tenant 만이 User 를 생성할 수 있다
    - User 와 Tenant 가 다른 애그리거트라고 무조건 다른 패키지내에 있어야 하는것은 아니다
    - 오히려 이 정도로 밀접한 애그리거트의 경우 같은 패키지내에 두는 것이 더 좋을 수 있다

## 유효성 검사
- 모델 내 유효성 검사를 사용하는 주 이유는 하나의 특성/속성, 전체 객체, 객체의 컴포지션 등의 정확성을 확인하기 위해서다
- 도메인 객체 내 모든 속성이 유효해도 객체가 유효하지 않을 수 있으며, 하나의 전체 객체가 유효해도 객체 컴포지션이 유효하지 않을 수 있다
  - 하나 이상의 단계로 이뤄진 유효성 검사를 통해 가능한 모든 문제를 다뤄야 한다

### 특성, 속성의 유효성 검사
- 속성에 비유효한 값이 설정되는 것을 막아야한다
- 필자는 자가 캡슐화의 사용을 강력 추천한다
  - 같은 클래스 내에서도 모든 데이터로의 액세스가 접근자 메서드를 거치도록 하는 방법이다
  ```java
  class EmailAddress {
    public EmailAddress(String address) {
      this.setAddress(address);
    }

    private void setAddress(String address) {
      if(address == null) {
        throw new IllegalArgumentException("address may not be set to null");
      }
      if(address.length() == 0) {
        // ...
      }
      // ...
      this.address = address;
    }
  }
  ```
- 길이 검사 등의 유효성 검사는 도메인이 할 필요 없다고 생각할 수 있는데, 결과적으로 한계가 많다
  - SQL 에러에서는 어떤 필드가 길이를 초과했는지 알려주지 않는 경우도 있다
  - setter 에서 길이를 확인해주는게 가장 최선책일 수 있다
- 저자는 속성 유효성 검사는 setter 에서 수행하라고 말하지만, Validator 로 분리하는 것도 괜찮을 것 같다
  - 테스트 관점에서 더 편리할 수 있다(엔티티나 Validator 를 mocking 할 수 있기때문에)
  - Spring Validation은 필드 레벨, 클래스 레벨을 참조한다

### 전체 객체의 유효성 검사
- 모든 속성이 유효해도 엔티티가 유효하지 않을 수 있다
  - 주문의 상태가 완료인데, 주문완료 시각이 null 이라면 이 엔티티는 유효하지 않다
  - 필드별로 하는 유효성검사에선 확인할 수 없는 내용이다
- 이 유효성 검사를 엔티티 내부에 넣기에는 엔티티의 책임이 너무 많아진다
  - 별도의 유효성 검사 클래스를 설계하고, 엔티티와 같은 패키지에 둘 수 있다
- 이 유효성 검사 프로세스에서 문제가 발생했을 땐, 예외를 던지는 것보다 전체 결과를 수집하는 편이 중요하다
- 외부 클라이언트에서 값들을 가져와서 이게 유효한지 체크하는 것 보단 내부에 validate 라는 메서드를 정의해서 엔티티 전체 유효성 검사를 간단하게 할 수 있게 해주는 것이 좋다
- 엔티티와 Validator 는 분리해주는 것이 좋다
  - 엔티티와 Validator 는 변하는 시점이 다르다(Validator 가 훨씬 많이 변한다)
  - 가독성을 위해서 같은 패키지내에 두는 것이 좋다
- 책에서는 Validator 슈퍼 클래스를 만들고, 각 엔티티마다 이 Validator 를 구현한 유효성검사 클래스를 만들도록 했다
  - 그리고 외부 클라이언트들이 이 Validator 를 사용해서 validate 를 수행한다
  - 클라이언트는 객체를 사용하는 모든 것들을 말한다

### 객체 컴포지션의 유효성 검사
- 애그리거트 여러개를 통합해서 유효성 검사를 해야할 경우, 도메인서비스라는 객체를 사용해 여러 엔티티의 유효성 검사를 수행한다
- 책에 있는 예제는 `특정 이벤트가 발생했을 때 이 유효성 검사를 수행해라` 라고 말하는 것 같다
  - 이게 무슨말?

# 변화 추적
- 기본적으로 엔티티 수명주기에 걸쳐 일어나는 모든 상태변경을 추적할 필요는 없지만, 도메인 전문가들은 종종 모델에서 일어나는 중요한 사건에 신경을 쓰므로, 이런 변경을 추적하는 행위는 도움이 된다
- 가장 실용적인 변경 추적은 도메인 이벤트와 이벤트 저장소이다(이벤트소싱)
  - 도메인 전문가가 신경쓰는 애그리게잇은, 상태를 바꾸는 커맨드마다 이벤트를 발행시킨다
  - 이벤트 수신자는 이를 받아서 이벤트 저장소에 저장한다