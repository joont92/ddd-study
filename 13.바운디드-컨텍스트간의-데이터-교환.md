바운디드 컨텍스트간의 데이터 교환
- 프로그래밍 랭기지 레벨의 직렬/역직렬화를 이용하는 것보다는 표준 포멧(XML, JSON) 사용
  - generator 로 만들어낸 것 사용 또
- shared kernel 이나 confirmst 가 바운디드 컨텍스트를 계속 엮이게 하는 것 같아서 지양하라고 하는 것 같음

- Restful API 를 통한 교환
- 메시징을 이용한 통합

바운디드 컨텍스트간에 직접 바로 연결하지 말고, 중간에 부패방지계층을 둠
- 인증 바운디드 컨텍스트 -> 협업 컨텍스트의 언어로 변환하는 역할 수행

도메인 이벤트 + 메시지가 DDD 를 잘 활용하는 것

한번 외부 바운디드 컨텍스트의 데이터를 담기 시작하면 계속 담아야함
- 이벤트가 순서대로 오지 않을 수 있다
  - 시간을 통해 일정부분 해결 가능
  - 이런 로직을 구현할테니, 보내는 쪽에서는 받았다는 확신이 들 떄 까지 계속해서 보내줘야함
  - version 으로 구분
  - 버퍼를 두고, 이 빠진 이벤트가 다 들어오게 되면 그때 로직 수행
- 이벤트가 여러번 도착할 수 있음(네트워크 장애는 언제든 발생하기 떄문에, 발신자 쪽에서 확인될 떄 까지 여러번 전송해야함)
  - 이벤트 처리는 멱등성있게 처리되어야 함
- publisher 의 모든 이벤트를 consumer 가 책임질 수 없다

이런식으로 다 책임질 수 없으니 책임을 회피하자
- 자신의 이벤트만 처리하고 나머지 이벤트는 다른 서비스로 책임을 전가시킴
A -> B -> C
A 에서 C 이벤트를 직접 받을수도 있지만 C 에서 A 의 이벤트를 받기에 괴리가 조금 있을 떄 B 를 이용

# 장기수행 프로세스
메시지를 던질 떄 TimeoutTracker 를 실행하면 장기 프로세스에서 발생할 수 있는 문제를 해결가능
- 처음 프로세스를 시작하는 곳에서 가져가는 것이 좋음
- time 이 지난 후에 validate 하고, 이후 재시도/완전 종료 구분
- 롤백은 어떻게 할것인가?

- 상태머신 도입
  - 필요한 스텝들이 완료되었을 경우 flag 를 업데이트 하는 기능을 도입
  - timetracker + 상태머신 도입?

saga 패턴을 쓰든, 상태머신을 도입하든 timetracker 를 도입해야함
- 혹은 quarts 를 띄워서 주기적으로 체크하거나

- 메시징 메커니즘이나 시스템이 죽었다 살아나더라도 다시 이벤트 구독이 시작되어야 함

urban 은 saga 하나가 5시간 정도되고, 주문이 하
saga : 이벤트 관장