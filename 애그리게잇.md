# 애그리게잇
- 간단히 말해 여러 엔티티, 값 객체들을 묶음 단위라고 보면 된다
- 묶음의 기준은 같은 도메인 범위인지, 라이프 사이클을 같이하는지 등을 보고 판단할 수 있다
- 예상했겠지만, 묶음의 기준을 정하는 것이 매우 중요하다

## 큰 단위의 애그리게잇과 다수의 애그리게잇
- 커다란 엔티티를 여러 트랜잭션에서 변경하려고 하다보니 Optimistic Locking 이 발생할 확률이 높다
- 트랜잭션 문제를 떠나서, 성능과 확장면에서도 좋지 않다
- 애그리게잇이 커질수록, 애그리게잇 내의 오퍼레이션들이 서로 관련있을 확률은 낮아진다
  - 애그리게잇 내의 오퍼레이션들이 서로 관련이 없다는 것은, 애그리게잇의 고정자가 잘못 설정되었음을 뜻한다
  - 또한 이러한 이유로 Optimistic Locking 이 자주 발생하게 된다

- 이런 애그리게잇은, 비즈니스 로직을 다시 살펴보면서 고정자를 다시 세팅하고, 다수의 애그리게잇으로 나눠주는 것이 좋다
  - Optimistic Locking 문제점을 해결할 수 있다
  - 아래와 같이 다른 애그리게잇을 리턴해주는 형태로 코드가 변한다
    ```java
    class Product {
      public BacklogItem planBacklogItem(/* ... */) {
        // ...
      }

      public Release scheduleRelease(/* ... */) {
        // ...
      }
    }
    ```
  - 애그리게잇이 다수가 됨으로써 클라이언트가 사용하기 불편해진다는 단점은 있다
  - IDDD 예제에서는 하나의 큰 Product 애그리게잇을 BacklogItem, Release, Sprint 등의 여러 애그리게잇으로 분리하였다


# 애그리게잇 규칙
## 한 트랜잭션당 한 애그리게잇 인스턴스만을 수정해야한다
- 한 트랜잭션에서 2개 이상의 애그리게잇을 수정해서는 안된다

## 진짜 고정자를 애그리게잇 경계 안에 모델링하라
- 바운디드 컨텍스트 내에서 애그리게잇을 찾으려면 모델의 진짜 고정자를 이해해야 한다
- 고정자를 알아야만 애그리게잇을 정할 수 있다
- 고정자는 언제나 일관성을 유지해야만 한다는 비즈니스 규칙이다
  - e.g. 배송시간과 도착시간(도착시간은 배송시간보다 빠를 수 없다)
  - 고정자의 단위가 커질수도 있는데(주문을 눌렀으면 결제가 이루어져야 한다 처럼), 책에서 `고정자에 관한 논의는 트랜잭션적 일관성과 관련이 있다` 라고 하는 것으로 보아, 범위가 한 바운디드 컨텍스트 내에서 인 것 같다
- **결국 애그리게잇은, 이러한 고정자를 단일 트랜잭션 내에서 완벽하게 일관성을 유지시켜줘야만 올바르게 설계된 애그리게잇이라고 할 수 있다**
- **올바르게 설계된 바운디드 컨텍스트는 어떤 상황에서든 한 트랜잭션당 한 애그리게잇 인스턴스만을 수정한다**

## 작은 애그리게잇으로 설계하라
- 큰 애그리게잇은 앞서 언급한 트랜잭션 문제를 가지고 있고, 성능과 확장성 면에서도 좋지 않다
  - 덩치가 큰 놈은 확장하기가 쉬울수가 없다
  - 엮여있는 다른 엔티티들이 많으므로, 단순한 오퍼레이션에도 성능이 많이 저하된다
- 애그리게잇은 너무 크지도 너무 작지도 않게 딱 적절하게 설계하는 것이 좋다
  - `루트 엔티티 + 최소한의 특성이나 값 타입 속성`만을 가지게 설계하는 것이 좋다
    - 애그리게잇이 2개 이상의 엔티티를 가지는 경우는 거의 없고, 대부분 루트 엔티티하나와 여러 값 객체들을 가진다
    - 애그리게잇을 내에는 엔티티보다 값 객체를 많이 써주는 것이 좋다
  - 도메인 전문가가 규칙으로 구체화하지 않더라도, 일관성을 유지해야 할 것들이 눈에 보이는 경우가 많다
    - 그 만큼을 `필요한 만큼`이라고 볼 수 있다
    - e.g. name 과 description 이 떨어진 모델링은 상상할 수 없다
- 크기가 작은 애그리게잇은 성능과 확정성이 더 좋을 뿐만 아니라, Optimistic Locking 발생 가능성도 작기 때문에 트랜잭션이 성공할 확률이 높다
- 유스케이스가 애그리게잇의 경계를 흔드는 경우가 있다
  - 유스케이스가 여러 트랜잭션에 걸쳐져 있는지, 하나의 트랜잭션 안에서 이루어지는지 잘 판단해야 한다
  - 후자의 경우 한번쯤 의심해봐야 한다
- 여러 애그리게잇 인스턴스 사이의 일관성을 유지하려는 노력은 우리가 고정자를 놓치고 있다는 의미일 수 있다
- 특정 유스케이스가 여러 애그리게잇을 하나의 애그리게잇으로 리모델링 하도록 이끌 수 있는데, 이때에도 비판적인 시각을 유지해야 한다
  - 여러개의 애그리게잇으로부터 완전히 새로운 개념의 애그리게잇을 찾아냈다고 하더라도, 이 모양이 큰 애그리게잇 설계로 이어진다면 이전의 언급한 문제에 그대로 다시 노출된다
  - eventually consistency 를 통해서도 이 유스케이스를 달성할 수 있다

## ID로 다른 애그리게잇을 참조하라
- 애그리게잇이 다른 애그리게잇의 참조를 가질 수 있다
- 애그리게잇과 애그리게잇이 참조하는 애그리게잇이 같은 트랜잭션 안에서 수정되선 안된다
  - 결과적 일관성을 사용해서 수정을 시도해야 한다
- 애그리게잇간에 참조를 애그리게잇 루트의 컴포지션으로 가지지 않고, 애그리게잇 루트의 ID를 통해 참조하도록 한다
  - 애그리게잇 자체를 참조하는 것이 아니므로 크기가 작아지고
  - 인스턴스를 가져올 때 같이 다른 애그리게잇들을 같이 들고오지 않아도 되므로, 메모리가 절약되고, 성능이 개선된다

- ID로 연결된 애그리게잇을 탐색하기 위해 리파지토리를 사용할 수 있다
  - 애그리게잇 내부에서 리파지토리를 이용하는 방법이 있다
    - 예제를 보니 리파지토리는 static 메서드를 통해 가져오고 있었다
    - 기존의 Spring DI 를 통해 가져오던 부분을 사용할 수 없게 될 것 같다
  - 애플리케이션 서비스가 리파지토리로 애그리게잇을 조회한 뒤 전달해 줄 수도 있다
- 애그리게잇 Id를 속성으로 가질 경우 아무래도 애그리게잇 내에서 repository 를 직접 접근하는게 나을 것 같다
  - 애플리케이션 서비스에서 애그리게잇을 조회해서 전달해주는 형태로 구현할 경우, 아무래도 여러방면에서 복잡하고 번거로워질 것 같다
- 여러 애그리게잇을 참조해서 결과를 내려줘야할 떄, 성능상의 문제가 발생한다면 세타조인이나 CQRS 등을 이용해 볼 수도 있다
  - 도메인 서비스 전달?

- IDDD 샘플을 봤을 때 대체적으로 아래의 형태로 구현되어 있는 것 같다
  - 커맨드의 파라미터에서 애그리게잇은 애그리게잇 id 로 참조
    ```java
    public void doSomething(TanantId tanantId, ProductId productId) {
      // ...
    }
    ```
  - VO 는 파라미터로 바로 VO 전달
  - 애그리게잇 내에 엔티티가 2개라면?
  - 애그리게잇이 다른 애그리게잇 내의 엔티티에 접근한다면?
  - 애그리게잇 내에서 리파지토리를 사용한다면 이것도 문제없을거라 생각됨
  - 보다보니 아주 괜찮아 보이네

## 경계의 밖에선 결과적 일관성을 사용하라
- 하나의 애그리게잇 인스턴스에서 커맨드를 수행할 때 하나 이상의 애그리게잇에서 추가적인 비즈니스 규칙이 수행돼야 한다면 결과적 일관성을 사용하자
- 한 인스턴스를 수정할 때, 그와 관련된 다른 수정이 완료될 때 까지 어느정도의 시간 지연을 용납할 수 있는지 도메인 전문가에게 물어보는 것이 좋다
  - 도메인 전문가는 이 부분에 대해 개발자보다 훨씬 관대할 수 있다
- DDD 모델 내에서 결과적 일관성을 지원하는 가장 실용적인 방법은, 도메인 이벤트를 사용하는 것이다
  - 애그리게잇의의 커멘드 메서드가 수행되면, 그와 관련된 이벤트를 발행한다
  - 구독자 애그리게잇은 이벤트를 받아서 각자 다른 트랜잭션에서 자신의 커맨드 메서드를 수행한다
- 구독자가 다른 클라이언트와 동시성 경합을 겪어서 수정에 실패할 경우
  - 메시지 리스너에서 exception 을 감지할 경우 재시도 해볼 수 있다
  - 몇번 재시도하고 최종적으로 실패한다면 다른 방법을 통해 이를 알리도록 한다

- **유스케이스를 수행하는 사용자가 데이터의 일관성을 보장해야 한다면** 트랜잭션적 일관성을 사용하고, 그렇지 않다면 결과적 일관성을 사용하자
  - 정확히 와닿지는 않지만 어느정도 이해가는 말이다..

# 규칙을 어겨야 하는 이유

# 발견을 통해 통찰 얻기
- 여기서는 BacklogItem과 Task를 각기 다른 애그리게잇으로 분리해야하는지 말아야 하는지에 대해 고민하는 과정을 보여준다

- BacklogItem 과 Task 의 유비쿼터스 언어를 보자
  - 이 둘은 서로 의존하는, 고정자이다
  - 그러므로 둘이 한 애그리게잇 내에 있는것이 올바른 설계이다
- BacklogItem 당 12개의 Task가 나올 수 있고, Task 하나당 12개의 EsitimationLogEntry 가 나올 수 있다
  - 최대 144개의 객체를 메모리로 한번에 로드하게 될 수도 있다
  - EstimationLogEntry 에 lazy 로딩을 사용한다면 1(BacklogItem) + 12(Task) + 12(EstimationLogEntry) 개의 객체만 메모리에 로드해도 된다
  - Task 를 별도의 애그리게잇으로 분리하면 1 + 12 + 12 대신 1(Task) + 12(EstimationLogEntry) 까지 호출 개수를 낮출 수 있다
- BacklogItem 이 동시성 경합을 일으킬 확률이 얼마나 될지도 확인해봐야 한다
  - BacklogItem 의 상태는 모든 Task의 남은 시간이 0이 될때에만 변경된다
  - 이런일은 자주 일어날 확률이 매우 낮으므로, 굳이 BacklogItem 과 Task 를 애그리게잇으로 분리하여 동시성 경합에 대비할 필요는 없다
- 유스케이스도 보자
  - BacklogItem 의 상태가 자동으로 변경되어야 한다면 하나의 애그리게잇으로 두고, 매번 상태를 체크하게 할 수 있다
  - 도메인 이벤트를 통해 결과적 일관성을 달성할 수도 있다

- 이러한 고민들을 계속 할수는 없고, 최종 결정을 내려야 한다
  - 팀은 아래와 같은 이유로 BacklogItem 애그리게잇 하나만 유지하는 방식을 채택했다
  - lazy 로딩을 사용했을 때 애그리게잇이 최대 25개의 객체를 로드하게 되는데, 이는 합리적 크기이다
  - 언급한 유스케이스를 모두 수용할 수 있다

# 애그리게잇 구현
- 하나의 엔티티를 애그리게잇 루트로 모델링하라
- 다른 애그리게잇은 Id 값 객체로 참조하라
- 애그리게잇 내의 필드들은 값 객체를 선호하라
  - 모델이나 인프라에서 의미있는 오버헤드를 야기하는 것이 아니라면, 이 방식이 최선의 선택지다
- `데메테르의 법칙`과 `묻지말고 시켜라`를 사용해라
  - 클라이언트는 서버의 내부 구조를 가능한 모르게 최대한 감춰야 한다
  - 클라이언트는 서버가 공개한 공개 인터페이스를 통해서만 기능을 수행해야 한다
    - 애그리게잇의 상태 수정은 클라이언트가 수행하는 것이 아닌, 애그리게잇만이 수행할 수 있다
  - 서버는 공개 인터페이스를 제공하고, 호출이 이뤄지면 적절한 내부 파트로 위힘해 해당 인터페이스를 완료하도록 해야한다
  - 모든 객체의 모든 메서드는 다음을 통해서만 메서드를 호출해야 한다
    - 그 자신
    - 자신에게 전달된 매개변수
    - 자신이 인스턴스화 하는 객체
    - 자신이 직접 액세스할 수 있는 스스로가 포함된 파트 객체
- 낙관적 동시성
  - 애그리게잇 내의 어떤 파트가 수정되든 version 이 올라가므로, 동시성 문제를 해결할 수 있다
  - 하지만 애그리게잇에서 값 객체가 아닌 엔티티를 사용할 때 문제가 될 수 있다
    - 실제로는 값 객체지만, 영속성 레이어의 문제 떄문에 엔티티로 관리하면서 값 객체로 쓰는 경우
    - 이럴 경우 해당 값 객체(엔티티)에도 낙관적 동시성을 구현함으로써 해결할 수 있다
    - 이 방식이 안될 경우 애그리게잇 루트의 version 을 직접 수정하도록 할 수도 있는데, 이는 양방향 연관관계에서만 가능하다(?)
- 의존성 주입을 피하라
  - 애그리게잇에 리파지토리나 도메인 서비스를 DI 하는 것은 나쁘다고 볼 수 있다
  - 리파지토리나 도메인 서비스를 애그리게잇으로 주입하는데 따르는 잠재적 오버헤드를 생각해보면 된다
  - 애그리게잇 커맨드를 호출하기 전에 의존성을 찾아주는 방법과 같은 설계원칙을 적용하면 해결될 문제이다
  - IDDD Sample 에서는 다음과 같은 클래스를 만들고, 이 클래스를 통해 리파지토리와 도메인 서비스를 관리하고 있다
    ```java
    public class DomainRegistry implements ApplicationContextAware {

      private static ApplicationContext applicationContext;

      public static CalendarIdentityService calendarIdentityService() {
          return (CalendarIdentityService) applicationContext.getBean("calendarIdentityService");
      }

      public static CalendarEntryRepository calendarEntryRepository() {
          return (CalendarEntryRepository) applicationContext.getBean("calendarEntryRepository");
      }

      // ....
    }
    ```