# 애그리게잇
- 간단히 말해 여러 엔티티, 값 객체들을 묶음 단위라고 보면 된다
- 묶음의 기준은 같은 도메인 범위인지, 라이프 사이클을 같이하는지 등을 보고 판단할 수 있다
- 예상했겠지만, 묶음의 기준을 정하는 것이 매우 중요하다

## 큰 단위의 애그리게잇
- 커다란 엔티티를 여러 트랜잭션에서 변경하려고 하다보니 Optimistic Locking 이 발생할 확률이 높다
- 트랜잭션 문제를 떠나서, 성능과 확장면에서도 좋지 않다
- 애그리게잇이 커질수록, 애그리게잇 내의 오퍼레이션들이 서로 관련있을 확률은 낮아진다
  - 서로 관련도 없는데 같은 애그리게잇에 있다는 이유만으로 Optimistic Locking 문제를 유발한다

## 다수의 애그리게잇
- 큰 애그리게잇이 여러개로 나뉘어지므로, Optimistic Locking 문제점을 해결할 수 있다
- 클라이언트가 사용하기 불편해진다는 단점이 있다

# 애그리게잇 규칙
## 진짜 고정자를 애그리게잇 경계 안에 모델링하라
- 바운디드 컨텍스트 내에서 애그리게잇을 찾으려면 모델의 진짜 고정자를 이해해야 한다
- 고정자를 정해야 애그리게잇을 정할 수 있다
- 고정자는 데이터가 변경되든 언제나 일관성이 유지되어야 하는 비즈니스 규칙이다
  - e.g. 배송시간과 도착시간(도착시간은 배송시간보다 빠를 수 없다)
- 어떤 오퍼레이션이 수행되든 상관없이 고정자가 계속 유지되도록 논리적으로 보장해준다
  - 애그리게잇은 주로 일관성 경계와 관련이 있다(트랜잭션 일관성 경계와 동의어다)

## 작은 애그리게잇으로 설계하라
- 큰 애그리게잇은 앞서 언급한 트랜잭션 문제를 가지고 있고, 성능과 확장성 면에서도 좋지 않다
  - 덩치가 큰 놈은 확장하기가 쉬울수가 없다
  - 엮여있는 다른 엔티티들이 많으므로, 단순한 오퍼레이션에도 성능이 많이 저하된다
- 애그리게잇은 너무 크지도 너무 작지도 않게 딱 적절하게 설계하는 것이 좋다
  - `루트 엔티티 + 최소한의 특성이나 값 타입 속성`만을 가지게 설계하는 것이 좋다
  - 도메인 전문가가 규칙으로 구체화하지 않더라도, 일관성을 유지해야 할 것들이 눈에 보이는 경우가 많다
    - 그 만큼을 `필요한 만큼`이라고 볼 수 있다
    - e.g. name 과 description 이 떨어진 모델링은 상상할 수 없다
- 애그리게잇이 2개 이상의 엔티티를 가지는 경우는 거의 없고, 대부분 루트 엔티티하나와 여러 값 객체들을 가진다
- 애그리게잇을 내에는 엔티티보다 값 객체를 많이 써주는 것이 좋다
- 유스케이스가 애그리게잇의 경계를 흔드는 경우가 있다
  - 유스케이스가 여러 트랜잭션에 걸쳐져 있는지, 하나의 트랜잭션 안에서 이루어지는지 잘 판단해야 한다
  - 후자의 경우 한번쯤 의심해봐야 한다
- 여러 애그리게잇 인스턴스 사이의 일관성을 유지하려는 노력은 우리가 고정자를 놓치고 있다는 의미일 수 있다
- 특정 유스케이스가 여러 애그리게잇을 하나의 애그리게잇으로 리모델링 하도록 이끌 수 있는데, 이때에도 비판적인 시각을 유지해야 한다
  - 여러개의 애그리게잇으로부터 완전히 새로운 개념의 애그리게잇을 찾아냈다고 하더라도, 이 모양이 큰 애그리게잇 설계로 이어진다면 이전의 언급한 문제에 그대로 다시 노출된다
  - eventually consistency 를 통해서도 이 유스케이스를 달성할 수 있다

## ID로 다른 애그리게잇을 참조하라
- 애그리게잇이 다른 애그리게잇의 참조를 가질 수 있다
- 애그리게잇과 애그리게잇이 참조하는 애그리게잇이 같은 트랜잭션 안에서 수정되선 안된다
  - 결과적 일관성을 사용해서 수정을 시도해야 한다
- 애그리게잇간에 참조를 애그리게잇 루트의 컴포지션으로 가지지 않고, 애그리게잇 루트의 ID를 통해 참조하도록 한다
  - 애그리게잇 자체를 참조하는 것이 아니므로 크기가 작아지고
  - 인스턴스를 가져올 때 같이 다른 애그리게잇들을 같이 들고오지 않아도 되므로, 메모리가 절약되고, 성능이 개선된다

- ID로 연결된 애그리게잇을 탐색하기 위해 리파지토리를 사용할 수 있다
  - 애그리게잇 내부에서 리파지토리를 이용하는 방법이 있다
    - 예제를 보니 리파지토리는 static 메서드를 통해 가져오고 있었다
    - 기존의 Spring DI 를 통해 가져오던 부분을 사용할 수 없게 될 것 같다
  - 애플리케이션 서비스가 리파지토리로 애그리게잇을 조회한 뒤 전달해 줄 수도 있다
- 애플리케이션 서비스가 조회해서 전달해 줄 경우 커맨드 메서드가 복잡해 질 수도 있기 때문에, 도메인 서비스를 전달해주거나 리파지토리를 내부에서 사용하는 방법이 더 나을수도 있다
  - 선택은 자유이다
  - 어떤 선택을 했듯, 하나의 요청(트랜잭션)에서 여러 애그리게잇을 수정하는 것은 허용되지 않는다
- 여러 애그리게잇을 참조해서 결과를 내려줘야할 떄, 성능상의 문제가 발생한다면 세타조인이나 CQRS 등을 이용해 볼 수도 있다
  - 얘는 도메인 서비스로 구현해야 할까?

## 경계의 밖에선 결과적 일관성을 사용하라
- 하나의 애그리게잇 인스턴스에서 커맨드를 수행할 때 하나 이상의 애그리게잇에서 추가적인 비즈니스 규칙이 수행돼야 한다면 결과적 일관성을 사용하자
- 한 인스턴스를 수정할 때, 그와 관련된 다른 수정이 완료될 때 까지 어느정도의 시간 지연을 용납할 수 있는지 도메인 전문가에게 물어보는 것이 좋다
  - 도메인 전문가는 이 부분에 대해 개발자보다 훨씬 관대할 수 있다
- DDD 모델 내에서 결과적 일관성을 지원하는 가장 실용적인 방법은, 도메인 이벤트를 사용하는 것이다
  - 애그리게잇의의 커멘드 메서드가 수행되면, 그와 관련된 이벤트를 발행한다
  - 구독자 애그리게잇은 이벤트를 받아서 각자 다른 트랜잭션에서 자신의 커맨드 메서드를 수행한다
- 구독자가 다른 클라이언트와 동시성 경합을 겪어서 수정에 실패할 경우
  - 메시지 리스너에서 exception 을 감지할 경우 재시도 해볼 수 있다
  - 몇번 재시도하고 최종적으로 실패한다면 다른 방법을 통해 이를 알리도록 한다

- 이와 같은 기법은 하나의 바운디드 컨텍스트를 넘어서, 분산 시스템에서도 동일하게 적용할 수 있다

- 올바르게 설계된 바운디드 컨텍스트는 한 트랜잭션당 한 애그리게잇 인스턴스만을 수정한다