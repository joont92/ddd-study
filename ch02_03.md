# 도메인, 서브도메인, 바운디드 컨텍스트
- 도메인은 소프트웨어가 해결할 문제의 영역, 조직이 포괄하는 업무의 영역, 조직이 수행하는 업무 등을 얘기한다
  - 여기서 핵심 도메인, 서브 도메인으로 나뉘어진다
- 보통 도메인 모델을 설계할 때, 하나의 큰 도메인 모델로 만들어야 한다고 생각할 수 있지만, 실제로 DDD 에서는 이를 지양하고 여러개의 서브 도메인 모델로 나눠서 구성하는 것을 지향한다
  - 처음 도메인 모델을 만들 때 빠지기 쉬운 함정은, **도메인을 완벽하게 표현하는 단일 도메인을 만드는 시도를 하는 것이다**
  - 여러 서브도메인 모델로 나눌 수 있는 소프트웨어 도메인 모델을 굳이 구분 짓지 않는다면, 변화가 계속됨에 따라 훨씬 큰 부담을 지게 된다  
- 서브도메인이 고유의 핵심 모델의 일부가 아니라 일련의 알고리즘과 같은 형태일 때도 있다
- 한개의 모델로 모든 서브도메인을 표현하려는 시도는 좋은 시도가 아니다
  - 같은 용어라도 의미가 다르고, 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문이다
  - 그러므로 하위 도메인마다 모델을 만들어야하고, 이를 명시적으로 구분해주는 경계가 필요하다
  - 이를 바운디드 컨텍스트라고 한다(모델의 의미를 구분지어줄 수 있는 경계?)
- 바운디드 컨텍스트는 비즈니스를 지원하기 위해 만들어진다
- 필수이지만 핵심이 아닌 도메인을 서브 도메인이라고 한다
  - 지원 서브도메인은 비즈니스에 어느정도 특화된 도메인이지만 핵심은 아닌 도메인을 말한다
  - 범용 서브도메인은 비즈니스에 특화되진 않았지만 전체 솔루션에 필요한 도메인을 말한다 e.g. UAA, 회계모듈, 지오코딩 등등

SaaSOvation 이 협업 시스템을 만들때,  
전체 도메인을 그려보고 언어적 레벨에서 경계를 나누었다면(User 바운디드 컨텍스트를 나누었다면)  
협엽 시스템에서 User 가 계속해서 등장해서 발목을 잡지 않고 Author 등의 언어로 분리될 수 있었을 것이다  
언급했듯이 User 라는 단어로 모든 바운디드 컨텍스트에서 사용하는 것은 불가능하고, 이것이 시스템 성장의 발목을 잡는다  

컨텍스트를 명시적으로 나누었을때 같은 바운디드 컨텍스트 내에서는 굉장히 명시적으로 표현되지만,  
다른 바운디드 컨텍스트와 의사소통이 필요하게 되면 불편함이 발생한다 -> 컨텍스트맵에서 해결 가능(?)  

## 문제점 공간과 해결책 공간
문제점 공간과 해결책 공간 평가를 사용해 엔터프라이즈 환경의 현재 상황을 전략적으로 평가하는 방법
- 도메인은 문제점 공간과 해결책 공간을 모두 가지고 있다
- 서브 도메인을 1:1로 바운디드 컨텍스트와 묶으려는 시도는 바람직한 목표다
  - 이런 접근은 문제점 공간과 해결책 공간을 잘 융합시키고, 도메인 모델을 목표에 따라 잘 구분된 비즈니스의 분야로 분명하게 구분해준다

- 문제영역은 도메인 내에 존재하는 것(시스템화 되지 않았을 수 있음)  
- 해결영역은 시스템화 된 것. 하나의 바운디드 컨텍스트?  

- 평가란 문제점이나 해결책을 명확하게 정의했는가를 평가하기 위한 지표?

## 바운디드 컨텍스트
- **도메인은 것은 코드로 표현되는 어떤 경계가 아니라 단순한 논리적 개념일 뿐이다**
  - `도메인 모델`이 실제 코드로 표현되는 부분이다
- 한개의 모델로 모든 도메인을 표현하려는 시도는 올바른 방법이 아니며, 불가능하다
  - 같은 용어가 컨텍스트에 따라 다른 뜻으로 사용될 수 있다
    - 카탈로그에서의 상품, 재고관리에서의 상품, 주문에서의 상품은 이름만 같이 실제 의미하는 것이 다르다
  - 논리적으로 같은 존재같아 보이지만 도메인에 따라 다른 용어를 사용하는 경우도 있다
    - 회원 도메인에서는 회원이지만 주문 도메인에서는 주문자로 불리기도 한다
- 위에서 언급한 언어의 경계가 되는 컨텍스트를 `바운디드 컨텍스트`라고 한다
- 바운디드 컨텍스트는 하나의 도메인 모델을 포함한다
  - 바운디드 컨텍스트는 하나의 물리적 시스템이다
- 도메인 모델내에 존재하는 개념은 해당 도메인 모델을 둘러싼 바운디드 컨텍스트와 언어적 연관성이 있어야 한다
  - 협업 바운디드 컨텍스트와 `사용자` 라는 모델은 연관성이 별로 없다
  - 만약 협업 바운디드 컨텍스트 내에 `사용자`라는 개념이 있다면, 다른 바운디드 컨텍스트로 분리해주는 것이 좋다
- 바운디드 컨텍스트는 도메인 모델의 존재를 담고 있는 명시적 경계이고, 주로 언어적 경계를 이룬다
  - 용어를 기준으로 구분한다
- 이상적으로는 하나의 도메인과 바운디드 컨텍스트가 일대일 관계를 가지면 좋겠지만, 현실은 그렇지 않을 때가 많다
  - 같은 도메인이라도 여러개의 바운디드 컨텍스트가 있을 수 있다
    - 주문 하위도메인에서 주문을 처리하는 팀과 결제 금액을 계산하는 팀이 따로 있을 수 있다
  - 용어가 명확하게 구분되지 못해 두 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다
    - 하나의 바운디드 컨텍스트에 여러 도메인 모델이 들어가면 내부에서 용어와 의미가 충돌할 가능성이 높아진다
- 후자와 같이 하나의 물리적 바운디드 컨텍스트가 여러 도메인을 포함했을 경우, 아래의 내용을 주의해야 한다
  - 포함한 모든 도메인이 사용하는 하나의 도메인 모델을 만들지 않도록 해야한다
    - 시스템내에서 패키지로라도 구분해주는 것이(논리적 바운디드 컨텍스트로) 좋다
    - 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해 확장이 어렵게 되는 상황이 발생할 수 있기 때문이다
- e.g. 출판사 시스템의 바운디드 컨텍스트 구현
  - 출판사 시스템의 각 라이프 사이클마다 개별적인 바운디드 컨텍스트를 사용한다
  - 책 객체의 식별자는 모든 바운디드 컨텍스트에 걸쳐 공유된다

- 마이크로서비스는 바운디드 컨텍스트를 각각 프로세스로 분리하여 모델이 자연스럽게 컨텍스트별로 분리되게 하며, 라이프사이클도 각자 가져가게 한다

- 만약 새로 들어오려는 개념이 해당 유비쿼터스 언어 안에 들어있지 않다면, 절대 안으로 들여선 안된다
- 이터레이션을 돌다보면 컨텍스트에 새로운 개념을 넣고, 빼고, 관계를 맺는 순간을 계속해서 마주하게 되는데 DDD 의 원칙이 여기에 더 쉽게 집중할 수 있게 도와준다
- 바운디드 컨텍스트는 정해진 크기가 없으며, 완전한 유비쿼터스 언어를 표현하기 위해 필요한 크기만큼 커야한다
- 잘못된 크기의 바운디드 컨텍스트가 만들어졌다면, 
  - **유비쿼터스 언어가 아니라** 아키텍쳐적 영향을 기준으로 컨텍스트를 나눴거나
  - 가용한 개발자 리소스로 작업을 분배하기 위해 컨텍스트를 나눴을 수 있다
- 바운디드 컨텍스트의 크기는 항상 신중히 생각해야 한다
- 하나의 바운디드 컨텍스트에는 하나의 팀이 할당되는 것이 좋다
  - 하나의 잘 정의되고 응집력 있는 도메인 전문가와 개발자의 팀이 명시적인 바운디드 컨텍스트 안에서 모델링된 하나의 유비쿼터스 언어에 집중하는 편이 가장 최선이다

### 바운디드 컨텍스트간 관계
- 바운디드 컨텍스트는 어떤식으로든 연결되게 되어있으므로, 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다
- 대표적으로 REST API 가 있다
  - 이는 상류 바운디드 컨텍스트에서 API 를 제공하고, 하류 바운디드 컨텍스트에서 필요할 때 마다 해당 API 를 호출해서 사용하는 방식이다
  - 대표적으로 검색이 있다
    - 블로그, 카페, 게시판 등의 서비를 제공하는 포탈은 각 서비스별로 검색 기능을 구현하지 않고, 검색 전용 시스템을 만든 뒤 다른 서비스들과 통합한다
- REST API를 통하든, 큐를 통하든 정보를 제공하는 쪽의 모델로 데이터가 제공되므로, 이를 사용하는 바운디드 컨텍스트에서는 상류 바운디드 컨텍스트 모델이 자신의 모델을 해치지 않게 하기 위한 완층지대가 필요하다
  ```java
  class RecSystemClient implements /*Something */ {
    @Override
    public List<Product> getRecommendationOf(Long productId) {
      List<RecommendationItem> items = externalRecClient.getRecs(productId);
      
      return toProducts(items);
    }

    private List<Product> toProducts(List<RecommendationItem> items) {
      return items.stream()
              .map(/* productRepository 조회 및 Product 모델로 변환 */)
              .collect(Collections.toList());
    }
  }
  ```
- 두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다
  - 이를 `공유 커널` 이라고 부른다
  - e.g. 운영자를 위한 주문관리 도구 시스템과 고객을 위한 주문 시스템
  - 공유 커널의 장점은 중복을 줄여준다는 것이다
  - 대신 두 시스템이 공유커널을 함부로 변경해서는 안된다
- 두 바운디드 컨텍스트가 아예 통합하지 않는 방법도 있다
  - 이를 `독립 방식 관계` 라고 부른다
  - 통합이 필요하다면 수동으로 이루어진다
    - e.g. ERP 시스템에 직접 입력 등
  - 규모가 커질수록 수동 통합에는 한계가 있다

# 컨텍스트 맵
- 나무만 보고 숲을 보지 못하는 상황을 방지하려면, 전체 비즈니스를 조망할 수 있는 지도가 필요하고, 이것이 컨텍스트 맵이다
- 컨텍스트 맵을 그리는데 정해진 형태는 없다
  - 간단히 화이트보드에 선과 도형을 통해 표현할 수 있다
집중할 것
- 컨텍스트 맵이 무엇인지, 당신의 팀에 어떤 도움이 되는지, 어떻게 더 쉽게 만들 수 있는지
- 사스오베이션의 세가지 바운디드 컨텍스트와 해당 컨텍스트 맵의 상세 내용
- 매핑을 사용해 컨텍스트간의 통합을 확대해봄
- 부패 방지 계층을 지원하는 경계 객체와 그들간의 상호작용 조사
- REST 기반 리소스와 사용하는 측의 도메인 모델 내 객체 사이의 로컬 매핑을 보여주는 변환 맵을 만드는 방식을 살펴봄

## 컨택스트 맵이 필수적인 이유
- 엔터프라이즈 급의 커다란 시스템의 인터페이스를 진흙 투성이라고 한다. 가지고 있는쪽 요청하는 쪽 모두 진흙투성이가 된다.
- 또는 순응주의자 관계가 된다. 미처 관계가 있는지 조차 모르고 고려의 대상이 되지도 않는다.
- 컨택스트 맵은 해결책 공간의 관점을 제공하기 위한 목적에 초첨을 둔다.
- 컨택스트 맵을 그리면 관계된 모든 다른 프로젝트들과의 관계를 신중히 생각해보도록 강요받게 된다.

## 컨텍스트 맵 그리기
- 미래를 상상해서 그리지 말고 현재를 그린다
- 다이어그램에 너무 많은 세부내용을 추가하는 일은 도움이 안된다
- 대화를 통해 전략적 통찰이 드러나는 순간 컨텍스트 맵에 추가한다
- 팀전체가 잘 볼수 있도록 벽에 붙여 둔다

---

- Domain 은 여러 Sub Domain 으로 이루어져 있음
- 한 바운디드 컨텍스트가 여러 도메인을 포함하고 있으면 바운디드 컨텍스트가 성장하기 힘들다
  - 용어의 충돌 때문에?
- 출판사 예제를 보면 바운디드 컨텍스트가 시스템 적 경계가 아니란걸 알 수 있다?
  - 하지만 책 내에서는 바운디드 컨텍스트를 하나의 소프트웨어 레벨로 보고 있긴 하다
- 출판사 예제를 보면, 도메인은 같지만 각 스텝에서 중시하는 부분들이 다르다
  - 그래서 이 부분들이 바운디드 컨텍스트로 나눠질 수 있다
한 서브도메인에 여러개의 바운디드 컨텍스트가 나오는건 안좋은 것인가?
- 각 컨텍스트마다 특정 단어가 나타내는 뜻이 다른건 바운디드 컨텍스트의 특징이지만, 이들이 합칠떄는 어떻게 해야 하는가?
  - 공유커널 같은걸 사용하면 될 것 같다
  - 이를 사용하지 않고 컨텍스트간에 용어를 맞추는건 좋은 선택이 아니지 않을까
- 한 서브도메인에 여러 바운디드 컨텍스트가 나오는것은 괜찮다..
- 그러나 하나의 바운디드 컨텍스트가 여러 서브도메인을 포함하는 것은 좋은 패턴이 아니다
  - Coupling(언어적 결합 포함)이 컨텍스트의 성장을 막는다