# 애그리게잇
- 아래의 애그리게잇 규칙들을 읽다보면 애그리게잇에 대한 감을 잡을 수 있다
- 애그리게잇은 엔티티나 VO 같이 특정 엔티티를 얘기한다기보단, 엔티티 경계에 관한 특정 룰 이라고 볼 수 있을 것 같다

## 진짜 고정자를 애그리게잇 경계 안에 모델링하라
- **애그리게잇을 찾으려면** 바운디드 컨텍스트 내에서 모델의 진짜 고정자를 이해해야 한다
- 고정자는 언제나 일관성을 유지해야만 한다는 비즈니스 규칙이라고 볼 수 있다
  - e.g. 픽업시간과 도착시간, 장바구니와 주문내역 등
- 이 고정자들 중에서도, 일관성을 트랜잭션 레벨로 유지해줘야 하는 애들이 있다
  - 트랜잭션적 일관성을 지켜줘야 하는 애들은 유비쿼터스 언어 내에서 도출할 수 있다
  - 얘네들을 묶어서 애그리게잇이라고 부른다
  - 또한 트랜잭션적 일관성이었던 애가 결과적 일관성으로 변경될수도 있다

## 한 트랜잭션당 한 애그리게잇 인스턴스만을 수정해야한다
- **올바르게 설계된 바운디드 컨텍스트는 어떤 상황에서든 한 트랜잭션당 한 애그리게잇 인스턴스만을 수정한다**
- 2개 이상의 고정자가 수정된다면, 애그리게잇이 잘못 설계되었을 수 있다

## 작은 애그리게잇으로 설계하라
- 덩치가 큰 애그리게잇은 확장에 좋지않고, 성능이 떨어진다
- 한 애그리게잇이 여러 오퍼레이션을 가지고 있으므로, 트랜잭션이 성공할 확률이 낮아진다
  - Optimistic Locking 을 말한다
  - 수행하는 operation 은 여러개인데, 하나의 version 만을 바라보고 있으니 당연히 동시성에 취약하다
  - **오퍼레이션이 여러개라는 것은 오퍼레이션끼리 관련이 없을 확률이 높다는 것을 의미하기도 한다**
  - 애그리게잇의 크기를 작게 설계하면 위의 문제점들을 해결할 수 있다
- 애그리게잇은 루트 엔티티와 최소한의 특성이나 값 객체들로 제한하는 것이 좋다
  - 대체적으로 애그리게잇은 하나의 루트 엔티티와 여러 값 객체들을 가진다
- 유스케이스가 하나의 트랜잭션 안에서 여러 오퍼레이션을 수행하도록 이끌때가 있는데, 이때는 한번쯤 유스케이스를 의심해봐야 한다
  - 결과적 일관성을 통해서 유스케이스를 달성할 수 없는지 살펴봐야 한다
- 애그리게잇이 다수가 됨으로써 클라이언트가 사용하기 불편해진다는 단점이 있을수는 있다
- 번외로, 애그리게잇을 여러개로 분리하면 아래와 같이 코드가 바뀐다
  ```java
  class Product {
    public BacklogItem planBacklogItem(/* ... */) {
      // ...
    }

    public Release scheduleRelease(/* ... */) {
      // ...
    }
  }
  ```

## ID로 다른 애그리게잇을 참조하라
- 애그리게잇간에 참조를 컴포지션으로 가지지 않고, 애그리게잇 루트의 ID를 통해 참조하도록 한다
  ```java
  class BacklogItem {
    private BacklogItemId backlogItemId; // 자시자신의 식별자
    private ReleaseId releaseId; // 다른 애그리게잇 루트의 식별자
  }
  ```
- **애그리게잇간에 의존이 심해지는 상황을 방지하기 위한 장치라고 판단된다**
  - 애그리게잇이 다른 애그리게잇을 가지게 되면, 큰 애그리게잇이 가지던 문제점을 그대로 다시 가지게 된다
  - 애그리게잇을 작게 나눈 이유가 사라진다
- 애그리게잇 내에서 리파지토리를 직접 사용하여 다른 애그리게잇을 가져올 수 있다
  - 필자는 이를 지양한다
  - 이 방식은 애그리게잇이 다른 애그리게잇을 직접 참조로 가지는 것과 별 다를것 없어서, 위의 문제점을 그대로 야기할 수 있다
- 필자는 애플리케이션 서비스에서 리파지토리로 조회한 뒤, 애그리게잇의 커맨드 메서드로 전달해줄 수 있다
  - 필자는 이를 지향한다
  - ID 로 애그리게잇을 참조하려고 하는 목적을 잘 달성할 수 있기 때문이다
  - 예제에서 애그리게잇 커맨드로 애그리게잇 루트 id 를 전달하는게 단절된 도메인 기법을 쓰는것처럼 보이지만, 실제로 보면 그렇지 않다
    - 해당 id 를 그냥 set 하는 정도로만 쓰고 있을 것 이다
- @OneToMany 에서는 성능저하가 있을 수는 있다
  - fk 로 쭉 조회해오는 것이 아닌 id 로 in 을 해야하므로..

- 여러 애그리게잇을 합쳐서 조회해야하는 상황이라면, 이를 위한 도메인 서비스를 만드는 것도 좋다
  ```java
  public ReleaseAndSprint(ReleaseId releaseId, SprintId sprintId) {
    Release release = releaseRepository.findOne(releaseId);
    Sprint sprint = springRepository.findOne(sprintId);

    return new ReleaseAndSpring(release, sprint);
  }
  ```
  - 여기서 조금 특이한점이 있는데, **도메인 서비스에서는 리파지토리를 직접 사용하고 있다는 점**이다
  - 근데 다시 한번 생각해보면, 도메인 서비스는 애그리게잇을 컴포지션으로 직접 참조했을 떄 발생하는 문제점과는 거리가 먼 레이어이다
  - 오히려 도메인 서비스는 애그리게잇 인스턴스를 사용할 수 밖에 없는 레이어이므로, 리파지토리를 직접 주입하는 것이 실용적이다

## 경계의 밖에선 결과적 일관성을 사용하라
- 하나의 애그리게잇 인스턴스에서 커맨드를 수행할 때, 다른 애그리게잇의 커맨드도 수행돼야 한다면 결과적 일관성을 사용하자
- 한 인스턴스를 수정할 때, 그와 관련된 다른 수정이 완료될 때 까지 어느정도의 시간 지연을 용납할 수 있는지 도메인 전문가에게 물어보는 것이 좋다
  - 도메인 전문가는 이 부분에 대해 개발자보다 훨씬 관대할 수 있다
- DDD 모델 내에서 결과적 일관성을 지원하는 가장 실용적인 방법은, 도메인 이벤트를 사용하는 것이다
  - 애그리게잇의의 커멘드 메서드가 수행되면, 그와 관련된 이벤트를 발행한다
  - 구독자 애그리게잇은 이벤트를 받아서 각자 다른 트랜잭션에서 자신의 커맨드 메서드를 수행한다
- 구독자가 다른 클라이언트와 동시성 경합을 겪어서 수정에 실패할 경우
  - 메시지 리스너에서 exception 을 감지할 경우 재시도 해볼 수 있다
  - 몇번 재시도하고 최종적으로 실패한다면 다른 방법을 통해 이를 알리도록 한다
  - 제대로 안 돌아갔을 경우에 대한 전략이 충분히 필요하다

- **유스케이스를 수행하는 사용자가 데이터의 일관성을 보장해야 한다면** 트랜잭션적 일관성을 사용하고, 그렇지 않다면 결과적 일관성을 사용하자

# 규칙을 어겨야 하는 이유
## 사용자 인터페이스의 편의

## 기술적 메커니즘
- 차라리 Optimistic Locking 이 발생하는게 더 나을수도 있다
- 여러 애그리게잇을 하나의 트랜잭션에서 커밋하는게 더 나을수도 있다

## 쿼리 성능
- id 로 연결하면 join 을 쓸 수 없다
- composition 으로 연결하면 애그리게잇인지 엔티티인지 헷갈릴 수 있다

# 발견을 통해 통찰 얻기
- BacklogItem 은 루트 엔티티외에 Task 엔티티를 가지고 있는데, 이를 다른 애그리게잇으로 분리할 수 있을까?
  - BacklogItem 과 Task 는 서로 의존된 속성인, 고정자라고 생각했다
    - 모든 Task의 남은 시간이 0이되면 자동으로 BacklogItem의 상태가 변경되기 때문이다
- 그런데 정작 다시 살펴보니, BacklogItem 의 상태가 변하는 순간은 고작 1번 정도였다
  - 이는 결과적 일관성으로 달성해도 되지 않을까?
  - 매번 Task를 돌면서 검사하는 방식 대신, 단순히 Task 시간의 합계를 구하는 방식으로 최적화 할 수 있다
  - 유스케이스 자체에서 자동 변경을 안 원할수도 있다(이건 완전 다른 얘기지만)
- 하지만 우리는 그것을 위해 매번 테스크를 다 호출해서 계산해야 한다
  - 게다가 테스크에 붙은 EstimationLogEntry 도 같이 호출해야 한다
  - 12개의 태스크까지 등록될 수 있다면, 최대 144개의 엔티티를 메모리에 계속 올려야한다
  - 그치만 또.. Task 를 지연로딩으로 바꾸면 호출 횟수를 24번으로 줄일 수 있다(태스크 12개 로딩 + 태스크 1개에 대한 EstimationLogEntry 12)

- 이런 여러가지 고민들을 한 다음에 선택을 내리는 것이 좋다
  - 도메인에 대한 더 깊은 통찰도 얻을 수 있기 떄문이다
  
# 애그리게잇 구현
- 하나의 엔티티를 애그리게잇 루트로 모델링하라
- 다른 애그리게잇은 Id 값 객체로 참조하라
- 애그리게잇 내의 필드들은 값 객체를 선호하라
  - 모델이나 인프라에서 의미있는 오버헤드를 야기하는 것이 아니라면, 이 방식이 최선의 선택지다
- `데메테르의 법칙`과 `묻지말고 시켜라`를 사용해라
  - 클라이언트는 서버의 내부 구조를 가능한 모르게 최대한 감춰야 한다
  - 클라이언트는 서버가 공개한 공개 인터페이스를 통해서만 기능을 수행해야 한다
    - 애그리게잇의 상태 수정은 클라이언트가 수행하는 것이 아닌, 애그리게잇만이 수행할 수 있다
  - 서버는 공개 인터페이스를 제공하고, 호출이 이뤄지면 적절한 내부 파트로 위힘해 해당 인터페이스를 완료하도록 해야한다
  - 모든 객체의 모든 메서드는 다음을 통해서만 메서드를 호출해야 한다
    - 그 자신
    - 자신에게 전달된 매개변수
    - 자신이 인스턴스화 하는 객체
    - 자신이 직접 액세스할 수 있는 스스로가 포함된 파트 객체
- 낙관적 동시성
  - 애그리게잇 내의 어떤 파트가 수정되든 version 이 올라가므로, 동시성 문제를 해결할 수 있다
  - 하지만 애그리게잇에서 값 객체가 아닌 엔티티를 사용할 때 문제가 될 수 있다
    - 실제로는 값 객체지만, 영속성 레이어의 문제 떄문에 엔티티로 관리하면서 값 객체로 쓰는 경우
    - 이럴 경우 해당 값 객체(엔티티)에도 낙관적 동시성을 구현함으로써 해결할 수 있다
    - 내부 엔티티만 바뀌어도 상관없으면 내부 엔티티의 version 을 쓰고, 그렇지 않아야 한다면 애그리게잇 루트의 version 을 직접 컨트롤하게 하는게 좋다  
- 의존성 주입을 피하라
  - 애그리게잇에 리파지토리나 도메인 서비스를 DI 하는 것은 나쁘다고 볼 수 있다
  - 리파지토리나 도메인 서비스를 애그리게잇으로 주입하는데 따르는 잠재적 오버헤드를 생각해보면 된다
  - 애그리게잇 커맨드를 호출하기 전에 의존성을 찾아주는 방법과 같은 설계원칙을 적용하면 해결될 문제이다
  - 애그리게잇 내에서 리파지토리를 쓰면 애그리게잇이 다른 애그리게잇을 쉽게 참조하게 되고, 경계가 무너질 확률이 높아진다