# 아키텍쳐
- 실재하는 진실된 품질 요구사항이 아키텍처의 사용 방법을 결정하도록 해야한다
  - 실패할 리스크를 줄이는데만 집중할 수 있다
  - 정당화할 수 없는 아키텍처를 사용함으로써 발생하는 실패 리스크를 줄일 수 있다
- 사용중인 모든 아키텍처의 영향을 정당화하고, 정당화 할 수 없으면 시스템에서 제거해야 한다
- 아키텍처는 얼마나 멋진지 판단하기 위한 척도가 아니다
  - 현재의 요구사항을 보고, 특정 아키텍처들이 문제를 어떻게 해결해줄 수 있는지를 판단한 뒤 아키텍처를 선택해야 한다

## 계층형
- 아래의 게층들로 구성되어 있고, 상위 계층이 하위 계층들에만 의존하는 형태
  ```
  - 사용자 인터페이스 계층
  - 애플리케이션 계층
  - 도메인 계층
  - 인프라 계층
  ```
- 엄격한 계층 아키텍처에서는 바로 아래 계층에만 연결되는게 원칙이지만, 보통 상위 계층이 하위 모든 계층과 연결될 수 있는 느슨한 구조로 사용한다
- 사용자 인터페이스 계층
  - 사용자의 뷰 요구사항 문제를 다루는 코드만 포함해야 한다
  - 비즈니스 지식을 표현하는 도메인 모델의 유효성 검사는 여기서 수행하지 않는다
- 애플리케이션 계층
  - 도메인 계층과 다르며, 도메인 로직이 전혀 없다
  - 영속성 트랜잭션과 보안을 제어할 수 있다
  - 알람 보내기, 이메일 작성 등을 담당할 수도 있다
  - 도메인 모델의 직접적인 클라이언트가 되며, 매우 경량으로 유지된다
    - 애플리케이션 서비스가 복잡하다면 도메인 로직이 애플리케이션 서비스로 새어나가고 있음을 나타내는 신호일 수 있다
  - 리파지토리를 사용해 애그리게잇 인스턴스를 획득하고, 오퍼레이션을 수행한다
  - 도메인 모델이 이벤트를 게시하도록 설계되었다면 애플리케이션 계층에서 이벤트에 구독자를 얼마든 등록할 수 있다?

- 의존성 역행 원리(DIP)  
  - 상위 수준은 하위 수준 모듈에 의존해선 안되고, 둘 모두 반드시 추상화에 의존해야 한다
  - 계층형 아키텍쳐에서는 상위 수준은 `사용자 인터페이스, 어플리케이션, 도메인 계층` 이 되고, 하위 수준은 `인프라스트럭쳐`가 된다
  - 3계층은 도메인 추상화 계층을 사용함으로써 의존하고, 인프라 계층은 도메인 추상화 계층을 상속받으면서 의존한다

아래는 리파지토리를 사용한 예시이다  
```java
class JpaUserRepository {
  private EntityManagerFactory entityManagerFactory;

  public User getUser(UserId userId) {
    EntityManager entityManager = emf.createEntityManager();
    return /* ... */;
  }
}
```
위 클래스는 문제가 있다  
Jpa 라는 구현 레벨의 기술이 코드에 드러나기 때문에 infrastructure 레벨로 내려갔는데, 반환타입이 도메인 레이어의 객체이기 때문이다  
이는 하위 계층이 상위 계층을 참조하면 안된다는 계층 아키텍처의 룰을 벗어나는 행위이다  
DIP 를 사용하면 이런 문제를 해결할 수 있다  
```java
// domain package
interface UserRepository {
  public User getUser(UserId userId);
}
// infrastructure package
class JpaUserRepository implements UserRepository {
  @Override
  public User getUser(UserId userId) {
    // ...
  }
}
```
이렇듯 구현 클래스에 직접 의존하지 않고 추상화된 계층에 의존해야 한다  
애플리케이션 서비스의 코드 변경없이 간단하게 영속성 계층의 구현을 변경할 수 있다(NoSQL 저장, 메시지 전달 등으로도 쉽게 바꿀 수 있음)

구현체를 위한 인터페이스를 만들어서 하위에서 상위로 참조하는 형태의 계층 역행을 없앤다

```
- 파라미터로 사용하는것도 의존이라고 볼 수 있는데, 그렇다면 UI 계층의 DTO 파라미터를 애플리케이션으로 전달하는 것도 잘못된 행위일까?
  - 애초에 DTO 가 UI 특화 인터페이스인가?
  - Request, DTO 로 구분하던 예전 방식은 맞는건가?
```

## 헥사고날(Port and Adapter)
- 애플리케이션과 도메인 모델이 연결되어 하나의 내부 로직으로 자리잡고, 여기에 여러 클라이언트(포트)들이 핸들러(어댑터)를 통해 연결되어 있는 형태이다
  - 클라이언트가 어떤것이든 핸들러만 만들어주면 손쉽게 내부 로직에 붙일 수 있다
- 애플리케이션(+도메인)은 유스케이스의 경계다
  - 다양한 클라이언트가 얼마나 연결될지나 출력 메커니즘을 뭘 사용할지에 기반해서 경계를 나누면 안된다
- 클라이언트와 저장소가 없더라도 애플리케이션과 도메인 모델을 설계해서 이 부분만 테스트 해볼 수 있다
- 헥사고날과 계층형은 뭐가 다를까?  
  - 어플리케이션 + 도메인을 하나의 큰 시스템으로 보고, 나머지는 어댑터를 통해 연결할 수 있는 input/output 로 바라보는게 좋다는 말인 것 같다
  - 사상을 다르게 해서 보자는 말인것 같다
  - 컨트롤러 -> 어플리케이션 -> 도메인 -> 인프라 의 구조로 꼭 보지만 말자
- input 은 핸들러 코드 구현하고 어플리케이션 코드를 호출하면서 쉽게 input 어댑터를 추가할 수 있고, output 은 어플리케이션 내에 구현된 인터페이스를 상속하면서 쉽게 output 어댑터를 추가할 수 있다

## SOA
- 독립된 업무 시스템으로 개발하지 않고 서비스 단위로 시스템을 개발하고, 이를 조합해서 업무를 구현하는 방식
  - 시스템을 나누는 기준에 대해 지표를 제공해주는 역할일까?
- 하나의 헥사고날 시스템은 다수의 서비스 엔드포인트를 지원한다

---

- DDD를 사용할때의 목표는 언어적으로 잘 정의된 완벽한 도메인 모델을 바탕으로 바운디드 컨텍스트를 생성하는 것이다
- 서비스 엔드포인트가(REST, SOAP 등) 바운디드 컨텍스트의 크기에 영향을 미쳐선 안된다
  - 잘 나뉘어진 언어를 조각낼 뿐이다

- 전체적으로 위 3개의 아키텍처가 각각 비교되는 아키텍처는 아닌 것 같다
  - 계층형 vs 헥사고날 vs SOA 는 아닌것 같다
  - 아마도 각각의 아키텍쳐를 나누었던 기준이 다 다를것 같다

# REST
- 아키텍처 스타일 : 해당 아키텍처를 사용할 때의 베스트 프랙티스?, 해당 아키텍처를 사용할 때의 개발 스타일?
  - RDB를 사용하면서 테이블 하나에 직렬화된 객체를 그대로 저장하고 있다거나, REST 를 사용하면서 HTTP의 이득을 하나도 얻고 있지 못하다면, 해당 시스템에는 다른 아키텍처가 더 맞다고 볼 수 있다
- REST 의 특징
  - 각 리소스는 하나의 URI를 가지며(URI는 반드시 하나의 리소스를 가리켜야만 한다) URI 를 통해 대상을 불러낼 수 있어야한다
  - 무상태로 소통한다
    - 세션 같은것에 의존하지 않고, 독립적으로 각각의 리소스에 엑세스 할 수 있게 해준다
  - 리소스를 객체로 볼 수 있고, HTTP 메서드를 객체의 인터페이스로 볼 수 있다
  - GET, PUT, DELETE 의 경우 멱등(idempotent) 하다
  - 서버 입장에서 response 에 리소스의 URI 를 넘겨야한다

## REST 와 DDD
- 도메인 모델이 RESTful HTTP 로 바로 노출되는것은 좋지 않다
  - 도메인 모델의 변경이 인터페이스에 바로 반영되고, 인터페이스의 변경이 도메인 모델에 영향을 미치기 때문이다
  - 인터페이스쪽에 별도의 바운디드 컨텍스트를 두고(DTO?), 이를 도메인 모델과 매핑하도록 설계하는 것이 좋다
- SMTP, ICAL? 처럼 표준 미디어 타입을 제시한다면 도메인 모델을 바로 노출해도 괜찮다?

# CQRS
- 우리의 도메인이 복잡하면 복잡할수록 도메인 데이터를 뷰에 매핑할 때 여러가지 어려운 상황이 발생한다
  - 뷰에서 보여주는 데이터가 여러 애그리거트를 묶어서 보여줄 경우
    - 여러 애그리거트에서 데이터를 취득한 후 DTO로 묶어주거나
    - 여러 애그리거트를 동시 탐색하는 파인더를 만들거나
    - 이에 더 특화된 패턴인 CQRS 를 쓰는 방법이 있다
- CQRS 는 이름 그대로 도메인 모델을 명령만을 위한 모델과 쿼리만을 위한 모델로 분리한다
  - 커맨드 : void
  - 쿼리 : return type 존재
- CQRS 는 복잡함을 해결하기 위한 기술이지, 복잡함이 탄생하는 기술은 아니다
- 명령 모델과 조회 모델이 다른 기술을 사용할 수 있다
  - e.g.명령 모델은 JPA, 조회 모델은 MyBatis
- 명령 모델과 조회 모델이 다른 저장소를 사용할 수도 있다
  - 명령 모델은 RDBMS, 조회 모델은 NoSQL
- 명령 모델과 조회 모델을 위한 테이블이 다르거나 저장소가 다를 경우, 각 데이터간 동기화는 이벤트를 이용한다
  - 동기적으로 업데이트 할수도 있고, 비동기적으로 업데이트 할 수도 있다
  - 동기적으로 업데이트 할 경우 두 모델이 같은 데이터베이스를 공유하며, 같은 트랜잭션을 사용해야 한다
    - 일관성이 완벽 보장되는 대신 처리 시간이 오래 걸린다
  - 시스템이 큰 부하에 걸려있고 업데이트 시간이 길다면 비동기적 업데이트를 사용한다
- 쿼리 모델의 경우 로직이 단순하므로(직접 DB에 쿼리하는 정도) 애플리케이션 서비스가 존재하지 않는 경우가 많다
  ```
  커멘드 API - 어플리케이션 서비스 - 도메인 로직 - 인프라
  쿼리 API - DTO/DAO - 인프라
  ```
- eventually consistency 는 있을 수 밖에 없으니 클라이언트에서 처리해야한다
  - 페이스북의 경우 일단 사용자가 입력한 값을 기준으로 포스트를 생성함으로써 동기화에 걸리는 시간을 해결한다
    - 동기화에 실패하면 한 1-2초 후에 문제가 발생했다고 알람이 뜬다
- RDB의 `최적화되게 저장하는것이 가장 중요, 뷰잉은 쿼리들을 통해 풀어라` 가 메인 사상이다

# 이벤트 주도 아키텍처
- 이벤트 외에 커플링이 없어진다
- 장기 실행 프로세스 : SAGA
  - 여러가지 파이프라인을 실행하고, 추적하는 애이다
  - 분산 트랜잭션을 처리하기 위함
  - <https://microservices.io/patterns/data/saga.html>
- AXON framework 에서 DDD 에 나오는 왠만한 전략적 기술들을 지원한다
- SAGA 가 너무 길어지면 안좋을 것 같다
  - 모든걸 SAGA로 처리하는건 별로 안좋다
  - 롤백이 필요한 애들만?
  - 트랜잭션과 비슷하게 생각하는게 좋지 않을까?

# 이벤트 소싱
- 객체의 마지막 상태를 저장하지 않고 변경된 이벤트 값만 저장
  - 그리고 모든 이벤트를 읽어서 객체를 만듦
- 장점(와닿지는 않는데..)
  - 데이터 트래킹
  - 이벤트 중복방지, 멱등성 보장
  - CQRS 를 적용해볼수 있어서
  - 트랜잭션 데이터의 경우 조금은 쓸만할 수 있나? AUD 를 유지하는것 보다 나을 수 있을까?
    - 어쩌피 대부분의 데이터들이 AUD 를 통해 이벤트를 쌓고 있었다
- 매번 다 읽는게 힘드니까 snapshot 을 중간중간에 만들어서 부하를 줄일 수 있다

# 데이터 페브릭
hazelcast 같은 캐싱기능으로 사용하자  
CQRS 랑 같이 써라?