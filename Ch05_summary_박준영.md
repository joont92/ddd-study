# 엔티티
- 긴 시간에 걸쳐 계속 변화할 수 있는 고유한 대상(고유 식별자를 가짐)
- 모델을 정의할 때 식별자와 그에 따른 수명주기에 집중하여야 한다
  - 엔티티의 특성이나 행동보단, 엔티티 객체를 식별하거나 매칭해서 찾을 떄 사용되는 엔티티 객체의 정의를 기본적인 특성까지 파고들어야 한다
  - 개념적으로 필수적인 행동과 그 행동에서 필요로 하는 특성만을 추가해야 한다

# 엔티티 식별자 생성 전략

## 사용자가 식별자를 제공한다
- 양질의 식별자를 생성하는 일을 사용자에게 의지하는 것이 좋지 않은 접근이다
  - 고유하더라도 올바르지 않을 수 있기 때문이다
- 사람이 읽을 수 있는 식별자가 반드시 필요한 상황에선 어느정도 적합할 수 있다
  - 식별자의 품질을 확보하려고 노력해보는 것도 좋은 투자가 된다
- 수정가능한 사용자 입력값은 고유 식별자로 사용해선 안된다

## 애플리케이션이 식별자를 생성한다
- UUID
  - 하이픈 포함 36 바이트, 하이픈 제외 32 바이트
  - 영속성 메커니즘과 같은 외부 교류가 필요없고, 상대적으로 생성이 빠른 식별자이다
    - 1초 동안 특정 종류의 엔티티가 무수히 생성되더라도 속도를 유지할 수 있다
  - 읽기 힘들기 때문에 일반적으로 사용자로부터 감춰지고, 대신 사람이 읽을 수 있는 참조기법을 사용한다
    - \<a\> 태그로 UUID 를 감출 수 있다
- UUID 의 개별 세그먼트의 신뢰 정도에 따라 아래와 같은 형태로 re-format 할수도 있다
  ```
  reformatted id : APM-P-2012-08-14-F36AB21C

  APM 은 컨텍스트 이름,  
  P는 Product 라는 리소스 이름,  
  2012-08-14 는 년도-월-일,  
  마지막 8글자는 생성된 UUID 의 초기 4byte
  > TIMESTAMP 에서 마지막 32bit를 나타낸다(second, millisecond, nanosecond 포함?)
  
  위처럼 ID 를 재구성했을 경우 아래와 같은 이점들이 있다
  - 클라이언트가 원시 식별자 포멧을 이해할 필요가 없다(가독성이 올라감)
  - 식별자내에서 추가적인 정보 획득 가능(생성 날짜, 리소스명)
  ```
  - 이렇게 reformat 된 식별자는 String 보다는 VO 를 써서 유지해주는 것이 더 맞다(e.g. ProductId)
- 애플리케이션이 제공하는 식별자를 위해 필자는 리파지토리를 사용한다고 한다
  ```java
  public class JpaProductRepository implements ProductRepository {
    public ProductId nextIdentity() {
      UUID uuid = UUID.randomUUID();
      /*
      process uuid
      */
      return new ProductId(processedUUID);
    }
  }
  ```

## 영속성 메커니즘이 식별자를 생성한다