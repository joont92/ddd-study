# 엔티티
- 긴 시간에 걸쳐 계속 변화할 수 있는 고유한 대상(고유 식별자를 가짐)
- 모델을 정의할 때 식별자와 그에 따른 수명주기에 집중하여야 한다
  - 엔티티의 특성이나 행동보단, 엔티티 객체를 식별하거나 매칭해서 찾을 떄 사용되는 엔티티 객체의 정의를 기본적인 특성까지 파고들어야 한다
  - 개념적으로 필수적인 행동과 그 행동에서 필요로 하는 특성만을 추가해야 한다

# 엔티티 식별자 생성 전략

## 사용자가 식별자를 제공한다
- 양질의 식별자를 생성하는 일을 사용자에게 의지하는 것이 좋지 않은 접근이다
  - 고유하더라도 올바르지 않을 수 있기 때문이다
- 사람이 읽을 수 있는 식별자가 반드시 필요한 상황에선 어느정도 적합할 수 있다
  - 식별자의 품질을 확보하려고 노력해보는 것도 좋은 투자가 된다
- 수정가능한 사용자 입력값은 고유 식별자로 사용해선 안된다

## 애플리케이션이 식별자를 생성한다
- UUID
  - 하이픈 포함 36 바이트, 하이픈 제외 32 바이트
  - 영속성 메커니즘과 같은 외부 교류가 필요없고, 상대적으로 생성이 빠른 식별자이다
    - 1초 동안 특정 종류의 엔티티가 무수히 생성되더라도 속도를 유지할 수 있다
  - 읽기 힘들기 때문에 일반적으로 사용자로부터 감춰지고, 대신 사람이 읽을 수 있는 참조기법을 사용한다
    - \<a\> 태그로 UUID 를 감출 수 있다
- UUID 의 개별 세그먼트의 신뢰 정도에 따라 아래와 같은 형태로 re-format 할수도 있다
  ```
  reformatted id : APM-P-2012-08-14-F36AB21C

  APM 은 컨텍스트 이름,  
  P는 Product 라는 리소스 이름,  
  2012-08-14 는 년도-월-일,  
  마지막 8글자는 생성된 UUID 의 초기 4byte
  > TIMESTAMP 에서 마지막 32bit를 나타낸다(second, millisecond, nanosecond 포함?)
  
  위처럼 ID 를 재구성했을 경우 아래와 같은 이점들이 있다
  - 클라이언트가 원시 식별자 포멧을 이해할 필요가 없다(가독성이 올라감)
  - 식별자내에서 추가적인 정보 획득 가능(생성 날짜, 리소스명)
  ```
  - 이렇게 reformat 된 식별자는 String 보다는 VO 를 써서 유지해주는 것이 더 맞다(e.g. ProductId)
- 애플리케이션이 제공하는 식별자를 위해 필자는 리파지토리를 사용한다고 한다
  ```java
  public class JpaProductRepository implements ProductRepository {
    public ProductId nextIdentity() {
      UUID uuid = UUID.randomUUID();
      /*
      process uuid
      */
      return new ProductId(processedUUID);
    }
  }
  ```

## 영속성 메커니즘이 식별자를 생성한다
- 데이터베이스로 sequence나 incremented 값을 얻었을 경우 결과는 언제나 고유하다
- 필요한 범위에 따라 2byte, 4byte, 8byte 의 고유값을 생성할 수 있다
- 값을 얻기 위해 데이터베이스까지 가야한다는 점이 단점이다
  - 애플리케이션에서 생성할 때 보다 많은 시간을 소모한다
  - 애플리케이션 내부에 값을 캐싱하는 방법도 있지만, 딱히 실용적이지 않다
- 데이터베이스 종류에 따라 `빠른 식별자 생성`과 `늦은 식별자 생성` 2가지 방식이 있다
  - 빠른 식별자 생성은 엔티티 저장전에 식별자를 얻을 수 있는 방법을 말한다
    - e.g. Oracle
  - 늦은 식별자 생성은 생성자 할당이 엔티티가 저장될 때 일어난다
    - e.g. MySQL
    - MySQL의 LAST_INSERT_ID 를 사용해 Oracle Sequence와 비슷하게 사용할 수 있다(참고 : <https://bryan7.tistory.com/101>)

## 또 하나의 바운디드 컨텍스트가 식별자를 할당한다
- 다른 바운디드 컨텍스트에서 검색해서 식별자를 가져오므로, 바운디드 컨텍스트간 통합이 필요하다(식별자의 검색과 매칭과 할당을 위함)
- 검색을 위해 계좌번호, 사용자명, 이메일 등과 같은 속성을 하나 이상 제공해야 한다
  - 여러 검색 결과가 나오는 경우 사용자가 선택할 수 있는 UI 도 필요하다
- 외부 바운디드 컨텍스트의 변경이 로컬 바운디드 컨텍스트에 영향을 미친다
  - 이때는 도메인 이벤트를 사용한 동기화가 필요하다
  - 경우에 따라 로컬 바운디드 컨텍스트가 외부 바운디드 컨텍스트로 push 를 하기도 한다
- 이 방법은 식별자 생성 전략 중 가장 복잡한 방법이므로(외부에 의존적이므로), 최대한 보수적으로 사용해야 한다

> - 어떤 식별자 할당 접근법을 사용했는지, 왜 사용했는지 적어보자
> - 빠른 식별자 생성으로 충분한지, 늦은 식별자 생성으로 충분하지 적고 이유를 적어보자

## 식별자
- 바운디드 컨텍스트간 이벤트를 주고받을 떄, repository 에 저장하기 전에 이벤트를 발생시킬 경우 항상 빠른 식별자 생성 전략을 써야한다
- 저장되지 않은 엔티티를 Set에 넣을 경우 식별자가 없으므로, 동등성 비교를 제대로 수행할 수 없게 된다
  - 식별자가 아닌 다른 속성과 비교하도록 구현해야 할수도 있다
  - 필자의 경우 이런 상황이 발생한다면 다른 속성 비교를 구현하기 보단 빠르게 가져와서 할당하는 방법을 선호한다고 한다
- 하이버네이트는 숫자 시퀀스와 같은 원시 타입(대리 식별자)을 식별자로 사용하는 편을 선호한다
  - 외부에는 이런 대리 속성을 감추는 편이 가장 바람직하다(도메인 모델의 일부가 아니기 때문)
  - 대리 식별자 외에 도메인 식별자를 추가로 만들어주는 것이 좋다
    - id : 대리 식별자, tanant_id + username : 도메인 식별자
- 식별자는 외부에서 수정되지 못하도록 해야한다
  - setter 를 숨긴다
  - setter가 이미 있다면 내부에 방어 코드를 작성한다(2번 이상 setting 될 경우 exception 등)
- 변경되는 값은 식별자로 사용할 수 없다
  - username 은 식별자가 될 수 있으나, password 의 경우 식별자가 될 수 없다

# 엔티티 만들기
- 아래는 책에 나온 사스오베이션 팀의 요구사항을 예시로 설명한다
- 요구사항 분석을 진행하면서 팀 내의 유비쿼터스 언어집을 만들고, 계속 다듬어가는 것이 좋다
  ```
  # 용어집 예제
  테넌트 : ~~~
  테넌트 활성화 : ~~~
  사용자 : ~~~
  암호화 서비스 : ~~~
  인증 서비스 : ~~~
  ```

## 속성 만들기
1. 불분명해 보이는 요구사항은 완전히 다시 정리해보는 것이 좋다
  - 분명한 부분들을 추출해낼 수 있다
  - 요구사항이 완성인지 미완성인지 체크할 수 있다
2. 요구사항을 읽고, 필요한 것이 엔티티인지 값 객체인지 판단한다
  - `변경된다` 라는 단어를 분석한다
    - 특정 값만 바꾸면 되는지, 값 전체가 변경되어야 하는지에 따라 엔티티냐 값 객체냐를 판단할 수 있다
    - 지금은 값 전체를 바꿀 필요없다
  - `인증` 이란 단어는 검색을 지원해야한다는 뜻이며, 이는 고유 식별자가 필요하다는 의미이다
    - 검색은 많은 대상 중 하나를 발견하기 위함이기 때문이다
  - 위와 같은 특징들로 봐서, 엔티티라고 확신할 수 있다
3. 엔티티인게 확정되었으므로, 식별자와 속성을 정의해야 한다
  - 엔티티가 사용되는 범위에 따라 식별자를 정의한다
    - 광범위하게 사용될 Tenant는 UUID를 식별자로, Tenant 내에서만 식별하면 되는 User는 username 을 식별자로 사용한다
  - 다른 엔티티에서도 사용될 광범위한 식별자라면, primitive 타입보단 특정 타입을 지정해주는게 더 좋다(e.g. TenentId)
  - 검색을 위한 필드도 추가 정의한다
4. 속성의 노출 범위를 지정한다
  - password 필드는 애그리게잇 범위를 넘어선 절대 드러나지 않고, AthenticationService 를 통해서만 접근할 수 있게 한다
  
## 행동 정의하기
1. 요구사항 내에서 엔티티의 행동을 찾는다
  - e.g. 테넌트 활성화, 사용자 초대 등
2. 한 엔티티에 너무 큰 책임이 부여될 경우, 별도의 엔티티로 분리할 수 있다
  - e.g. User 엔티티에서 개인적 데이터를 담는 부분을 Person 엔티티로 분리
3. 다른 애그리게잇과 동기화가 필요하다면 이벤트를 발생시킬 수 있게끔 한다

### 역할 인터페이스
- 경우에 따라 한 객체가 여러 역할을 모두 수행하게 만들수도 있는데, 이 경우 인터페이스로 구분해주는 것이 좋다
  ```java
  interface User { /* ... */ }
  interface Principal { /* ... */ }
  class UserPrincipal implements User, Principal {
    // ...
  }
  ```
- 위의 경우 역할 인터페이스의 범위가 큰데, 좀 더 작은 단위로 역할 인터페이스를 만드는게 좋을수도 있다
  ```java
  interface AddOrdersToCustomer { /* ... */ }
  class Customer implements AddOrdersToCustomer {
    // ...
  }

  ...

  AddordersToCustomer customer = customerRepository.get(id);
  customer.addOrder(order);
  ```
- 인터페이스를 통해 구현 클래스에서 필요한 부분만 노출시킬 수 있다
  - 도메인 모델 구현 클래스는 지저분할 수 밖에 없다
- 위임은 복잡하게 만들지 않으며 단순하게 해줄때만 좋은 설계다
  - 아래는 복잡한 위임의 예시이다
  ```java
  interface Principal{ /* ... */ }
  class PersonPrincipal implements Principal { /* ... */ }
  class SystemPrincipal implements Principal { /* ... */ }
  class UserPrincipal implements Principal {
    PersonPrincipal personPrincipal;
    SystemPrincipal systemPrincipal;

    @Override
    public Name principalName() {
      if(personPrincipal != null) {
        return personPrincipal.principalName();
      } else {
        return systemPrincipal.principalName();
      }
    }
  }
  ```
  - UserPrincipal 이 위임을 하면서 자신의 식별자를 유실시켰는데, 이를 객체 정신 분열증이라고 한다