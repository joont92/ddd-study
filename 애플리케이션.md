# 애플리케이션
## 도메인 객체의 렌더링
- 사용자 인터페이스는 주로 태스크 달성에 필요한 수준보다 더 풍부한 데이터를 제공해야 한다(뷰로서의 이점)
- 종종 다수의 애그리게잇 인스턴스의 속성을 렌더링 할 필요가 있다

### DTO
- 한 뷰에 표시되어야 하는 모든 특성을 가진다
- 애플리케이션 서비스가 리파지토리를 사용해 여러 애그리게잇 인스턴스를 읽고, 이를 DTO 에 매핑하여 반환한다
  ```java
  class BacklogItemDTOAssembler {
    public BacklogItemDTO assemble(Product product, BacklogItem backlogItem) {
      // ...

      return articleDto;
    }
  }
  ```
- DTO에 애그리게잇 내부의 모습이나 구조가 많이 드러나지 않아야한다
- DTO 는 말 그대로 다른 레이어로 데이터를 옮겨주는 객체이고, 여기선 어플리케이션 레이어 -> 뷰 레이어로의 데이터 전송을 위해 사용된다
### 중재자
- 중재자를 구현하고, 중재자 인스턴스를 애그리게잇의 메서드로 전달하고, 애그리게잇은 중재자에 값을 채워서 반환한다
  ```java
  class BacklogItem {
    public void provideTaskInterest(TaskInterest interest) {
      Set<Task> tasks = this.allTasks();
      interst.informTaskCount(tasks.size());
      for(Task task : tasks) {
        // ...
      }
    }
  }
  ```
- DTO 랑 뭐가 다른지 잘 모르곘다
### DPO
- 다수의 전체 애그리게잇 인스턴스를 모아 단일 페이로드 객체로 변환한 것이다
- 개별 특성이 아니라 전체 애그리게잇 인스턴스로의 참조를 담도록 설계된다
  ```java
  class SomeDPO {
    private Product product;
    private BacklogItem backlogItem;
    // ...
  }
  ```
- 이 패턴은 아래와 같은 단점을 가진다
  - 애그리게잇에게 getter 를 만들어줘야 한다
  - 인스턴스 참조만을 가졌기 떄문에, 내부의 지연 로딩된 객체/컬렉션을 가졌을 경우 lazy loading exception 이 발생할 수 있다
  - 이를 위해 강제로 lazy loading 하도록 하드코딩할수도 있으나, 그보단 지연로딩 객체를 즉시 패치하도록 쿼리를 맞추는 편이 낫다
### 유스케이스 최적 쿼리
- DTO, DPO 등으로 매핑하는 대신, 유스케이스 최적 쿼리를 사용하는 방법이다
- 리파지토리에 탐색자 쿼리 메서드를 작성하고, 특별히 설계된 값 객체에 결과를 매핑한다
- 이 방식을 택했을 경우 이미 CQRS와 너무 가까워진 상태이므로, 그냥 CQRS 로 변경하는 것이 나을수도 있다

## 애플리케이션 서비스
- 도메인 모델의 직접적인 클라이언트이다
- 유스케이스 하나의 흐름당 하나의 서비스 메서드가 호출되도록 태스크를 조정하는 책임이 있다
- 트랜잭션, 보안도 이 레이어가 같이 관리한다
  - e.g. Spring 의 `@Transactional`
  - e.g. Spring Security 의 `@PreAuthorize`
- 아래는 애플리케이션 서비스 내 메서드의 시그니처로 사용되는 스타일들이다
  - 도메인 모델의 일부 타입이 사용된다(값 객체?)
  - 오직 원시타입과 DTO 만을 사용한다
  - 커맨드 객체를 사용한다
    - 커맨드 객체는 수행될 오퍼레이션에 의해 명명되기 때문에, DTO 이상의 역할을 수행한다
    - 커맨드 객체는 오퍼레이션 마다 생성되고, DTO 는 뷰를 위해 생성된다?
    - 커맨드 객체는 뷰로 반환될 수 있는가?
    - 커맨드 객체는 도메인 레이어로 전달될 수 있는가?
  
  - DTO나 커맨드 객체를 사용하면 의존성과 커플링을 피할 수 있지만, 값 객체로부터 거저 얻을 수 있는 강력한 타입검증과 유효성 검사등을 포기해야 한다
- 도메인 로직에 있어야 할 로직이 애플리케이션 서비스로 새어나가선 안된다
  - 도메인 로직은 최대한 가벼워야 한다
- 서비스는 단순히 아래 정도의 역할만을 수행하는 것이 좋다
  - 도메인에서 받은 메시지를 다른 도메인이나 서비스에 전달하기
  - 도메인 객체에 메시지 보내기
  - 트랜잭션 바인딩
  - 외부 인프라스트럭쳐와 상호작용(데이터베이스 등)
- 도메인 레이어는 단순 db mapper 이고, 서비스 레이어에서 이 값들을 가져와서 로직을 수행하는 것은 지양해야 한다
  - 여기저기서 값을 가져와서 로직을 수행하다보니 비슷한 로직이 여기저기 중복될 가능성이 높아진다
  - 서비스 레이어는 기본적으로 테스트하기 힘들기 떄문에, 이를 도메인 레이어로 옮기고 도메인 객체를 테스트하는 것이 훨씬 수월하다
- 애플리케이션 서비스를 void 로 선언하고, 클라이언트에게 데이터를 반환하지 않는 방향을 선택할수도 있다
  - 헥사고날 아키텍쳐의 포트와 어댑터를 사용하는 경우 이렇게 구성할 수 있다

- 애플리케이션 서비스는 서비스 팩토리나 의존성 주입을 통해 사용할 수 있다