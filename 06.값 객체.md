# 값 객체
- 값 객체는 DDD의 필수 요소다
- 가능한 위치에선 엔티티 대신 값 객체를 사용해 모델링하도록 노력해야한다
  - 값 객체는 생성, 테스트, 사용, 최적화, 유지관리 등이 더 쉽다
- 라이프사이클, 히스토리를 관리할 애들만 엔티티로 만들고, 나머지는 전부 값 객체로 만들어라

# 값 객체의 특징

## 측정, 수량화, 설명
- 값 객체는 도메인 내에 있는 개념이 아니다
- **도메인 내에 있는 어떤 대상을 측정하고, 수량화하고, 설명하는 개념이다**
  - 도메인 내에서 이런 개념을 유지하는 객체라는 뜻이지, 범용적으로 무언가를 측정하는 객체만을 만들어야 한다는 의미는 아님
  - 유비쿼터스 언어를 기반으로 이를 만족해야 한다는 점이 중요하다
- 값 객체만으로는 하나의 구체적 대상이 될 수 없음(식별할 수 없음)
- key + encrypt key 가 있는 EncryptKey 클래스는 값 객체일까?
- identifier 가 없다는게 가장 큰 특징인 것 같다
- `주소`는 각 서비스에서 기본적으로 값 객체로 사용할 수 있지만(구,군,리 등을 설명하므로), 주소 서비스에서는 엔티티로 사용될 것이다

## 불변성
- 객체가 인스턴스화 된 후 부터는 어떤 메서드도 값 객체의 상태를 변경할 수 없다
  - **생성자를 제외한 어떤 메서드도 세터를 호출하지 못하도록 구현해야 한다**
- 생성자에선 해당 인스턴스 상태의 기반이 될 값을 매개변수로 받는다
- 엔티티 참조를 갖는 값 객체가 있을수도 있는데, 값 객체를 통해 엔티티의 속성을 변경하게 되면 결국 불변성을 위반하게 되므로 좋지 않은 디자인이다
  - 값 객체에서 엔티티의 값이 필요하다면 엔티티 대신 엔티티 내부의 속성을 전달하는 식으로 사용하는 것이 좋다

## 개념적 전체
- 값 객체는 하나 이상의 속성을 가질 수 있으며, 각 속성은 서로 연관돼 있다
- 특성이 모여 전체를 나타낸다
  - 모든 특성이 있어야만 완벽히 의도에 맞는 측정이나 설명이 만들어진다
  - 특성을 개별적으로 사용한다면 응집력 있는 의미를 제공하지 못한다
  - Grouping 과는 다르다
- 예시
  ```java
  class MonetaryValue implements Serializable {
    private BigDecimal amount;
    private String currency;

    public MonetaryValue(BigDecimal amount, String currency) {
      setAmount(amount);
      setCurrency(currency);
    }
  }
  ```
  - `금액` 이라는 개념을 사용하기 위해선 amount 와 currency 가 같이 사용되어야 한다
- 관련 로직을 해당 값 객체로 중앙 집중화 할 수 있다
  ```java
  class ThingName implements Serializable {
    private name;
    
    public ThingName(String name) {
      setName(name);
    }

    private void setName(String name) {
      // validation check

      this.name = name.substring(0, 1).toUpperCase() + name.substring(1).toLowerCase();
    }
  }
  ```
- 값 객체 내의 전체 값 생성은 한번의 생성자 호출로만 수행되어야 한다
  - 초기값을 세팅하고, 이후 setter 등을 통해 값을 채워나가선 안된다
- 이 객체를 참조하고 있는 대상에게 이 객체는 하나의 속성이다
  ```java
  class ThingOfWorth {
    private ThingName name;
    private MonetaryValue worth;
  }
  ```

## 대체성
- 상태를 변경할 필요가 생겼다면, 새로운 값 인스턴스를 생성해 현재 값을 완전히 대체해야 한다
  ```java
  FullName name = new FullName("Vaughn", "Vernon");
  // ...
  name = new FullName("Vaughn", "L", "Vernon");
  ```
- primitive 타입의 값 교체와 동일한 방식이다
- `참조`라는 특성에서 올 수 있는 사이드이펙트를 없앤다
- 값을 변경할 수 없으니 당연히 필요한 요소이다
- 애그리게잇에 사용되는 고유 식별자의 경우(e.g. MemberId) 이러한 대체성 특징이 필요하진 않다
  - 그래도 값 객체로 사용할 수 있다

## 값 등가성
- 값 객체 인스턴스간 타입과 특성이 모두 같다면, 해당 인스턴스들을 등가로 간주한다
- equals, hashCode 예제
  ```java
  @Override
  public boolean equals(Object obj) {
    if(obj == null || getClass() != obj.getClass()) {
      return false;
    }

    FullName target = (FullName) obj;
    return this.getFirstName().equlas(target.getFirstName()) 
            && this.getLastName().equals(target.getLastName());
  }

  @Override
  public int hashCode() {
    return Objects.hash(getFirstName(), getLastName());
  }
  ```
  - 자가 캡슐화를 사용해 이미 값에 대한 null 검증을 끝냈으므로, 등가비교에는 null 비교가 필요없다

## 부작용이 없는 행동
- 특정 오퍼레이션을 수행할 때 어떠한 수정도 발생하지 않는다면, 해당 오퍼레이션은 부작용이 없다고 말한다
- 값 객체의 메서드는 부작용이 없는 메서드여야 한다
  - 불변성을 침해하지 않기 위해서이다
  - 함수형 프로그래밍 언어는 이런 특징을 강화하였다(불변성 값 객체만을 받아들이기 등)
- 예제
  ```java
  public FullName withMiddleInitial() {
    // validation
    return new Fullname(
      getFirstName(),
      middle.substring(0, 1).toUpperCase(),
      getLastName()
    );
  }
  ```
- 위에서도 언급했지만 매개변수로 전달한 인스턴스의 값이 변경되는 것은 부작용이다
  - 값 객체에 매개변수로 엔티티를 전달하지 말고 내부 속성 일부만을 전달하도록 변경하는 것이 좋다
- primitive 타입을 사용했을 경우 위와 같이 우리 도메인에 맞는 추가 함수를 할당할 수 없다
  - 그러므로 값 객체를 사용하는 것이 좋다!
  - 하지만 정말 특별히 처리할 부분이 없는 단순한 특성이라면, primitive 타입을 사용해도 괜찮다

# 미니멀리즘으로 통합
- 한 애그리게잇에서 다른 애그리게잇의 데이터를 사용할 경우 값 객체로 변환해서 받아오는 것이 좋다
  - 영향과 책임을 최소화한다
- 동기화가 필요할 경우 애그리게잇으로 모델링하라?

# 표준 타입
- 리소스의 타입을 말함
- 이를 표현하기 위해 하위타입을 많이 정의할 수 있지만, 복잡성이 증가하므로 표준 타입으로 선언하는 것이 좋다
- 이런 표준 타입들은 엔티티보다 값 객체로 모델링하는 것이 좋다
- 표준타입은 identity, name, description 같은 특성들을 가진다
  - 예전에는 database 에 이를 전부 저장했었다
  - 지금은 어플리케이션을 안 거치는 서비스가 없기 때문에, 이를 어플리케이션 내에 정의하기도 한다
  - 자바 enum 을 사용하면 이를 편하게 구현할 수 있다
    - enum 자체에 여러 속성, 메서드들을 넣을 수 있기 때문
    - 보통은 외부에서 상태를 활용하며, `이 상태` 일 때 특정 행동을 수행하지만, 이러기보다 상태 자체에 특정 행동을 부여하는 것을 권장하고 있다
- 표준 타입이 텍스트 설명을 가지는건 때때로 부적합하다
  - 뷰에 따라 달라질 수 있으므로(지역화 등)
- 하이버네이트에서 표준타입은 숫자, 표준타입 이름 그대로 저장하는 방법이 있는데, 이름을 그대로 저장하는 방법이 좀 더 바람직하다(?)

# 값 객체 테스트
- 모델이 모든 측면에서 완벽하다고 증명하려는 목적이 아님
- 클라이언트가 도메인 모델의 다양한 객체를 사용하는 방법과 해당 클라이언트가 이를 사용할 때 기대하는 결과가 무엇인지에 더 관심이 많음
- **모델을 설계하며 필수적인 개념을 포착하기 위해선 클라이언트의 관점을 가정해보는 과정이 필수적이다**
- 팀의 표준을 다루는 모든 추가적인 테스트는 반드시 작성해야 한다
- 테스트는 반드시 도메인 전문가의 입장에서 의미가 있어야 한다
  - 비개발자인 도메인 전문가가 이 테스트를 읽고 이해할 수 있어야 한다
- 테스트를 위해 테스트 클래스 내 헬퍼 메서드를 만들 수 있다
- 값 객체의 메서드를 수행 후 등가비교를 수행함으로써 부작용이 발생하지 않았는지 체크한다
  ```java
  SomeValue someValue = new SomeValue(/* */);
  SomeValue someValueCopy = new SomeValue(someValue);
  
  someValue.doSomething();
  
  assertThat(someValue).isEqualTo(someValueCopy);
  ```
  - 위처럼 값 객체를 사용할 경우 모든 경우에서 불변성이 보장되어야 한다

# 구현
- 값 인스턴스는 직렬화가 필요한 경우가 있어서 Serializable 로 선언하는게 좋다(?)
- 값 객체 내 속성들은 전부 값 객체로 만들어줘야 한다
- 값 객체의 경우 생성자를 최소 2개 작성해주는 것이 좋다(필자의 의견)
  - 값 객체를 생성하는데 필요한 매개변수들이 있는 생성자
  - 기존의 값을 복사해 새로운 값을 생성하는 복사 생성자
    - 기본적으로 swallow copy 를 사용함
    - deep copy 를 지원할수도 있지만 대개 불필요하다
      - 불변 값을 다루기 때문에 인스턴스 사이에 객체가 공유되어도 문제가 되지 않기 떄문이다
    - 이 생성자는 불변성 검증 단위 테스트에서 주로 활용된다
- 함수의 메서드 이름 또한 중요하다
  - 자바빈 명세인 getXXX 보단 명시적인 이름을 사용하자
  - e.g. getValuePercentage() -> valuePercentage(), getTotalValue() -> totalValue()

> 자바빈 명세는 객체 설계에 부정적인 영향을 미쳤다  
> 자바빈 명세를 지킬경우 객체는 불변성을 위반하므로, 이 형태로 객체를 작성해서는 안된다  
> 만약 특정 라이브러리나 프레임워크에서 자바빈 명세를 필요로 한다면, DTO 를 사용해 이를 해결해보는 것이 좋다  

- 등가 조건을 위해서 equals(), hashCode() 를 항상 같이 구현해야 한다
- 자가 캡슐화를 하고, 여기서 assertion 을 수행해주는 것이 좋다
  - 잘못된 데이터를 받지 않을 수 있도록 막아주기 때문이다
  - 만약 데이터가 잘못되었다면 IllegalArgumentException 을 발생시킨다

# 값 객체의 저장
- 설계시 데이터 모델부터 거꾸로 올라오지 말고, 도메인 모델로 부터 데이터 모델로 내려가라
  - 데이터 모델은 도메인 모델을 영속화하는 목표만 있을 뿐이다
  - 도메인 모델을 위해 데이터 모델을 설계해야지, 데이터 모델을 위해 도메인 모델을 설계해선 안된다
- 데이터 모델에 어떤 기술을 사용하든, 그에 해당하는 엔티티/기본키/인덱스 등이 도메인 모델링 방법을 주도하도록 해서는 안된다
  - DDD는 비정규화된 방식으로 데이터를 구조화하는 문제에 대한 것이 아니다
  - 일관된 바운디드 컨텍스트 내에 유비쿼터스 언어를 모델링하는데 관한 문제이다

- 기본적으로 값 객체는 비정규화되어 엔티티와 같은 테이블 행에 저장된다
- 가끔씩 값 객체가 데이터 모델에서 테이블로 저장되어야 할 경우가 있다
  - 값 객체 컬렉션을 지원할 떄 주로 발생한다
- 위와 같은 상황이 발생하더라도, 절대 값 객체를 엔티티로 변경해서는 안된다
  - 이런 불일치를 마주했을 경우, 영속성 관점보다는 도메인 모델의 관점을 유지하는 것이 중요하다
  - 이러한 문제를 거쳤을 경우, 가능한 모든 단계를 거치며 현명하게 대처해야 한다

## 단일 값 객체 저장
- 기본적인 전략은 비정규화하여 같은 테이블에 저장하는 것이다
- naming 은 필자의 경우 아래의 방법을 추천했다
  - {값 객체 이름}_{속성}
  - 값 객체가 BusinessPriority 일 경우, business_priority_ratings_benefit
  - 부모 값에서 각각의 개별 특성으로 이어지는 탐색 경로에 기반한다
- 같은 행에 저장되므로, 조인을 사용할 필요가 없다

## 값 객체 컬렉션 저장

### 한 열로 직렬화하기
- 컬렉션의 모든 객체를 JSON 등으로 직렬화한 후에 하나의 열로 저장한다
- 데이터베이스 입장에서 몇가지 단점이 있지만, 이 방법으로 얻게되는 장점을 생각했을 경우 해당 단점은 무시할만한 수준이 된다
- 이 방식을 택할 경우, 아래의 특징들을 고려해봐야 한다
  - 열 넓이
    - 컬렉션에 들어간 값이라 직렬화된 값의 최대 크기를 단정할 수 없다
    - 직렬화된 텍스트가 열의 최대 가능 너비를 초과해 오버플로우가 발생할수도 있다
    - 최대 너비를 결정할 수 없을 경우 이런 방식은 피하는 것이 좋다
  - 쿼리해야 할 경우
    - 컬렉션 값에 쿼리가 불가능하다
    - 컬렉션 값 객체로 쿼리하는 경우는 드물기 때문에, 이런 이유로 포기할 가능성은 작다

### 값 타입을 데이터 모델의 엔티티로 취급해서 저장하는 방법
- 1:N 엔티티 관계로 연결하는 방법이다
- 엔티티가 아니라 값 객체를 연결한 것이기 때문에, 엔티티의 특성인 `식별자`는 감춰주는 것이 좋다
- 아래는 필자가 추천하는 대리식별자를 숨기는 방식이다
  ```java
  public abstract class IdentifiedDomainObject {
    private Long id = -1;

    public IdentifiedDomainObject() {
      super();
    }

    protected setId(Long id) {
      this.id = id;
    }

    protected Long id() {
      return this.id;
    }
  }

  public abstract class IdentifiedValueObject {
    public IdentifiedValueObject() {
      super();
    }
  }

  /*
  value object extends IdentifiedValueObject
  entity extends IdentifiedDomainObject
  */
  ```
  - 대리식별자가 감춰지고 명시적여지는 장점이 있는데.. 난 좀 긴가민가 하다
- 데이터 모델에서는 엔티티이지만, 이는 오직 데이터 모델의 관점에서일 뿐이고, 도메인 모델에서는 분명한 값 객체다

### @ElementCollection
- 하이버네이트는 위의 구현을 위한 기능을 이미 제공한다
- 컬렉션 요소가 다른 테이블에 저장되며, 부모 테이블의 식별자를 외래키로 가진다
  - 따로 대리식별자를 가지지 않는다
- 조인이 필수적이다
  - 이는 위의 방법도 마찬가지다
- 컬렉션에 있는 깂 객체의 어느 값도 null 로 세팅될 수 없다
  - 대리식별자가 없기떄문에 필드값으로 고유함을 식별할 수 있어야 탐색, 삭제가 가능하기 때문이다
  - 이 특징의 위의 방법과 다른 점이다


- ORM 은 테이블 저장시 무조건 @Entity 를 달아야하는데, 값 객체에 이걸 다는게 조금 이상할 때가 있다

- 값 객체는 비정규화해서 넣는게 좋다?
  - 근데 그러면 컬럼의 개수가 너무 늘어나게 되는데..
- 값 객체 리스트를 쿼리할 요구사항이 없다고 한다면, 그냥 serialize 하여 한 컬럼에 저장하라

- 값 객체 리스트를 엔티티로 저장할 경우 식별자는 숨기는게 좋다(실제로는 저장하지만)
  - 오버헤드가 가장 적지만.. 조금의 인지 부조화가 일어난다
  - 값 객체인데 DB 에 id 가 있고, JPA 사용시 @Entity 어노테이션을 사용한다거나..

- @ElementCollection 으로 저장

이벤트 소싱에서 엔티티의 컬럼이 삭제되더라도 코드상에서는 삭제할 수 없다?  
코드 추가의 경우 그냥 null 세팅하면 되지만...  

ORM 이랑 VO 랑 애초에 좀 안 맞는것이 아닌지..  